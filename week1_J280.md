# 📝 Quest 수행 기록

## 🎯 선택한 퀘스트
- **Quest1** : README.md 자동 생성  
- **Quest4** : AI를 통한 집중력 확인해보기  

---

## ✨ 선택한 이유

### Quest1: README.md 자동 생성
1. 평소에 `README.md` 작성이 어렵다고 느꼈기 때문에 이번 기회에 **효율적인 작성 방식**을 찾아보고 싶었습니다.
2. 자동화 도구나 AI를 활용하여 **꾸준히 사용할 수 있는 나만의 템플릿**을 만들어, 이후 프로젝트에 적용하고자 선택했습니다.
3. 퀘스트를 계기로 리드미 작성의 **형식과 규칙을 정의**하고 싶었습니다.

### Quest4: AI를 통한 집중력 확인해보기
1. 퀘스트를 너무 열심히 준비해주신 것이 느껴졌고, 설명이 **재미있고 흥미로워 보여서 선택**하게 되었습니다.
2. **재미와 스릴이 가미된 활동이라면 힘든 공부도 조금 더 수월하게 느껴질 것** 같다고 생각했습니다.
3. 공부를 할 때 가끔 이런 **가벼운 흥미 요소가 동기 부여에 도움이 된다고 느껴** 선택하게 되었습니다.

---

## 🔧 수행 과정

### Quest1: README.md 자동 생성

#### 🚀 수행 방법
- 바로 마지막 day9 미션에서 완성한 코드를 토대로 README 작성을 이용하기로 결정하였다.
- GPT를 이용했고 아래 프롬프트 2개와 코드를 복사해주었다.
- 프롬프트 1
  ```prompt
  너는 숙련된 개발자이고, 프로젝트 문서를 아주 잘 작성하는 전문가야. 아래의 [템플릿 양식]에 맞춰서, [내가 작성한 내용]을 정리해 완벽한 README.md 파일을 마크다운 형식으로 만들어줘.

  # 🚀 스레드 레이스

  > 학습 키워드

  ## 🛠️ 설계과정

  ## ✨주요기능

  - [기능 1]
  - [기능 2]
  - [기능 3]
  ```
- 프롬프트 2
  ```prompt
  학습 키워드는 > #IPC, #레이스 컨디션 #멀티 스레드야 ㅜㅜ 그리고 내 코드를 더 줄게! 코드의 주요 함수나 기능에 대한 설명도 해줬으면 좋겠어.
  [코드1]
  [코드2]
  ```

#### ✅ 결과
<details>
<summary>최종 생성된 README.md 파일</summary>

# 🚀 스레드 레이스

**멀티스레드 환경에서의 작업 분배, 경쟁 상태(Race Condition), 락(Lock) 처리, IPC(프로세스 간 통신)** 등을 학습하고 시뮬레이션하는 Node.js 기반 프로젝트입니다.

> **학습 키워드**  
> `멀티스레딩` `Worker Threads` `SharedArrayBuffer` `Atomics` `Lock` `Race Condition` `IPC` `스레드 스케줄링`

---

## 🛠️ 설계 과정

- `worker_threads` 모듈을 활용해 메인 스레드와 워커 간 병렬 처리 구조를 설계
- 공유 자원(`balance`)을 안전하게 조작하기 위해 `SharedArrayBuffer` + `Atomics` 기반의 락 메커니즘을 구현
- 워커는 역할 기반(`deposit`, `withdraw`, `inquiry`)으로 분기되어 작업 요청 및 수행을 반복
- IPC 통신은 `parentPort.postMessage()`와 `.on('message')`로 구성
- 각 워커는 작업이 없으면 요청을 재시도하며, 모든 작업이 끝나면 순차적으로 종료

---

## ✨ 주요 기능

- ✅ **역할 기반 워커 생성 및 분리된 작업 처리**
- `deposit`, `withdraw`, `inquiry` 역할의 워커들이 생성되고 자신에게 맞는 작업만 수행

- ✅ **공유 자원 보호**
- `SharedArrayBuffer`와 `Atomics.compareExchange()` 기반의 락 구현
- 레이스 컨디션 없이 잔액(balance)을 안전하게 입출금

- ✅ **스레드 간 IPC 통신 구현**
- 메인 스레드와 워커가 메시지를 통해 작업 요청, 로그 전달, 종료 신호 등을 주고받음

- ✅ **랜덤 딜레이 + 비동기 처리**
- 각 작업은 `setTimeout` 기반의 비동기 랜덤 지연을 포함해 현실성 있는 처리를 모방

---

## 📁 프로젝트 구조 예시

```
📦 thread-race/
┣ 📜 main.js         # 메인 스레드 - 작업 생성 및 워커 관리
┣ 📜 worker.js       # 워커 스레드 - 역할 기반 작업 처리
┣ 📜 README.md       # 프로젝트 소개 및 문서
```

---

## 🧠 주요 함수 설명

### 🔧 main.js

| 함수/이벤트 | 설명 |
|-------------|------|
| `new Worker()` | 역할별 워커를 생성하고 `shared` 버퍼 전달 |
| `worker.on('message')` | 워커로부터 로그, 요청, 완료 등의 메시지를 수신 |
| `worker.postMessage({ type: 'task' })` | 워커에게 작업 전달 |
| `worker.postMessage({ type: 'terminate' })` | 모든 작업이 완료되면 워커 종료 신호 전송 |
| `sharedView[0]` | 락 인덱스 (LOCK_INDEX) |
| `sharedView[1]` | 잔액(balance) 저장소 (BALANCE_INDEX) |

---

### 🔧 worker.js

| 함수 | 설명 |
|------|------|
| `acquireLock()` | 락이 0일 때만 점유, 아니면 대기 (`Atomics.wait`) |
| `releaseLock()` | 락 해제 후 대기 중인 스레드 깨움 (`Atomics.notify`) |
| `log(msg)` | 로그를 메인 스레드로 전송하며 타임스탬프 포함 |
| `deposit()` | 랜덤 금액 입금, 락으로 보호된 공유 자원 접근 |
| `withdraw()` | 랜덤 금액 출금, 부족 시 `insufficient balance` 출력 |
| `inquiry()` | 잔액 조회 후 로그 출력 |
| `parentPort.on('message')` | 메인으로부터 작업(task) 또는 종료(terminate) 메시지 수신 |

---

## ✅ 실행 예시 (콘솔 로그)

```
tasks: [ 'deposit', 'withdraw', 'inquiry', ... ]
[워커 준비 완료] threadId: 2, 역할: deposit
[워커 준비 완료] threadId: 4, 역할: inquiry
(15:03:12.123) [2] deposited 430
(15:03:12.834) [4] 현재 잔액 : 430원
(15:03:13.542) [3] withdraw 210
...
모든 worker가 종료되었습니다.
최종 공유 자원 값 (balance): 1270원
```

---

## 📌 학습 포인트 요약

| 항목 | 설명 |
|------|------|
| 🧵 멀티스레딩 | Node.js의 `worker_threads` 기반 워커 병렬 처리 |
| 🔐 동기화 제어 | Atomics로 구현한 락 처리로 공유 자원 보호 |
| 💬 IPC | 메인-워커 간 메시지 기반 통신 구조 |
| ⚠️ 레이스 컨디션 | 락 없이는 발생할 수 있는 Race Condition 직접 시뮬레이션 가능 |


---

## 🧠 참고 자료

- [Node.js 공식 문서: worker_threads](https://nodejs.org/api/worker_threads.html)
- [MDN Web Docs: Atomics](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics)
</details>

- 일단, README를 작성하는 시간을 많이 생각할 수 있었고, 이모티콘을 활용해 보기에 더 이쁜 문서를 작성할 수 있었다.

#### 💭 느낀 점
- 인공지능이 생각보다 내 코드 전반을 잘 이해하고, 틀을 주면 거기에 맞춰서 쓰는 능력은 꽤 수준급이라고 생각되었다. 다만 출처같은 건 내가 참고하지 않았는데도 함부로 붙여오는 경향을 보아 거짓말을 하는 점은 잘 안 고쳐지는 듯하다. ㅎㅎ

- 그래도 README를 너무 GPT에게 전반적으로 맡기는 것은 다른 분들이 보기에도 성의가 없어보이고 내가 의도한 바를 온전히 전달하는데는 좋지 않다고 생각되어 자주 사용하지는 못할 것 같다.

---

### Quest4: AI를 통한 집중력 확인해보기

#### 🚀 수행 방법
- 일단 사용 방법대로, 카메라를 눈높이에 맞춘 뒤에 정자세를 유지하며 사용하게 되었다. 또한 미션 내내(최소 10시간) 하라는 것은 아니겠지 싶어 내가 체크리스트에 분리해놓은 task 중 하나를 수행하는 동안 통과하는 것을 목표로 삼았다. 또, 모니터를 여러 개 사용하면 고개를 돌리는 것에 제약이 생겨 하나의 모니터만 사용할 수 있었다.
#### ✅ 결과
- 집중 유지 시간은 1시간 이상이었던 것 같고, 알람 기능은 활성화되지 않아서 일일이 집중되고 있는지 확인하며 체크하였다. 체크한 바로는 계속 집중이었고 생각보다 오랜 시간 동안 자리도 못 뜨고 정자세를 유지하느라 허리와 목이 많이 뻐근했다.
- 장난스러운 미션이라고 생각했는데 생각보다 큰 챌린지가 되었었다.

#### 💭 느낀 점
- 집중력에는 당연히 도움이 되었다. 이 작업을 빨리 끝내고 미션을 완수하고 싶었기에 정말 최선을 다해 노력해보았던 것 같다! 다만.. 미션 단위로 하기보다는 내가 한 자리에 정자세를 유지하고 싶은 최대 시간을 설정하고 그 시간 동안 실행하는 것이 바람직한 것 같다. 한 작업이 그렇게 짧지 않은 시간 동안 진행될 수도 있기 때문에 고문이 될 수도 있다.
