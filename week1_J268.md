
## QUEST1. README.md 자동 생성

- README.md를 작성하지 않은 리포지토리를 무슨 내용인지 한눈에 파악이 가능할 것 같기 떄문에 선정하게 되었습니다.
- 추가적으로 파일을 업로드할 수 있는 AI 에이전트에서 작성한 코드까지 검토해 README.md를 작성해봐도 좋을 것 같습니다.

**README 템플릿**

---

## 개요

- 항목

## 📝 요구사항 분석

### 기능 및 구현

- 항목

### 테스트

## 📐 설계

### 📌 항목

## 💻 구현

### 📌 항목

---

**만들어 준 README.md**

---

<details>
<summary>접기/펼치기</summary>

## 개요

이 프로젝트는 Node.js 환경에서 **동기/비동기 처리**, **멀티 스레딩**, **Race Condition 관리**, 그리고 **발행-구독(Publisher-Subscriber) 패턴**의 심층적인 이해와 구현을 목표로 합니다. 특히, Node.js의 이벤트 루프 동작 방식과 멀티 스레드 환경에서의 효율적인 이벤트 관리 및 데이터 동시성 문제를 해결하는 방법에 중점을 둡니다.

## 📝 요구사항 분석

### 기능 및 구현

- **동기/비동기 개념 학습**: Node.js의 동작 방식 및 비동기 처리를 위한 Event Loop 메커니즘을 이해합니다.
- **프로세스, 스레드, 코루틴 학습**: 각 개념의 차이점과 동작 방식을 파악합니다.
- **멀티 스레드 동작 및 활용 조건**: 멀티 스레드가 어떻게 동작하며, 활용하기 위한 전제 조건을 학습합니다.
- **CPU 스케줄링 학습**: 비동기 작업을 CPU가 효율적으로 처리하도록 할당하는 스케줄링 방식을 이해합니다.
- **공유 영역 동시 접근 문제 처리**: 공유 자원에 동시에 접근할 때 발생하는 문제와 해결 방안을 학습합니다.
- **이벤트 처리 방식 학습**: 이벤트 발생 시 이를 처리하는 다양한 방식을 이해합니다.
- **디자인 패턴 학습**: Publisher-Subscriber 패턴과 Observer 패턴의 차이점, 구현 방법, 그리고 Singleton 패턴의 적용 이유를 학습합니다.
- **메시지 큐 학습**: 메시지 큐의 개념과 이벤트를 처리하는 방법을 이해합니다.

---

## 📐 설계

### 📌 멀티 스레드 Race-condition

- **멀티 스레드 환경 설정 도구 선정**: Node.js의 `worker_threads` 모듈을 활용하여 멀티 스레드 환경을 구성합니다.
- **Race-condition 발생 설계**: `worker_threads`를 사용하여 여러 스레드가 동시에 공유하는 변수(예: 카운터)에 접근하여 값을 증가시키는 작업을 수행하도록 설계하여 의도적으로 Race Condition이 발생하도록 합니다.
- **Race-condition 처리 기준 및 설계**:
    - **처리 기준**: Race Condition으로 인한 데이터 불일치 문제를 해결하고, 공유 자원의 일관성을 보장하는 것을 목표로 합니다.
    - **설계**:
        - **Mutex/Semaphore**: 상호 배제(Mutex) 또는 세마포어(Semaphore)와 같은 동기화 메커니즘을 사용하여 공유 자원에 대한 접근을 제어합니다. Node.js `worker_threads`에서 제공하는 `Atomics` 객체를 활용하거나, 별도의 락(Lock) 구현을 고려합니다.
        - **메시지 패싱**: 공유 메모리를 직접 조작하는 대신, 스레드 간 메시지 패싱을 통해 데이터를 교환하여 Race Condition의 발생 가능성을 줄입니다.
            
### 📌 멀티 스레드 환경에서의 발행-구독 패턴을 구현하는 이벤트 매니저

- **Node.js EventEmitter를 사용한 Publisher-Subscriber 패턴 구현 요소 설계**:
    - **Publisher**: 이벤트를 생성하고 `EventManager`에 해당 이벤트를 발행하는 역할을 수행합니다. `EventEmitter` 인스턴스를 내부적으로 사용하여 이벤트를 발행합니다.
    - **Subscriber**: `EventManager`에 특정 이벤트를 구독하고, 해당 이벤트가 발행되었을 때 정의된 콜백 함수를 실행하는 역할을 수행합니다. `EventEmitter.on()` 메서드를 사용하여 이벤트를 리스닝합니다.
    - **EventManager**:
        - **중앙 집중식 이벤트 관리**: `Node.js EventEmitter`를 상속받거나 포함하여 모든 이벤트 구독 및 발행을 처리하는 중앙 허브 역할을 합니다.
        - **이벤트 등록/해제**: `on()`, `off()` (또는 `removeListener()`) 메서드를 통해 `Subscriber`가 이벤트를 등록하거나 해제할 수 있도록 제공합니다.
        - **이벤트 발행**: `emit()` 메서드를 통해 `Publisher`로부터 받은 이벤트를 구독하고 있는 모든 `Subscriber`에게 전달합니다.
        - **Singleton 패턴 적용**: 애플리케이션 내에서 `EventManager`의 인스턴스가 하나만 존재하도록 Singleton 패턴을 적용하여 일관된 이벤트 관리를 보장합니다.
- **동기, 비동기, 지연 처리가 가능한 이벤트 큐 설계**:
    - **이벤트 큐**: 발행된 이벤트를 임시로 저장하는 큐를 구현합니다. `Array` 또는 `Map`과 같은 자료구조를 활용할 수 있습니다.
    - **처리 방식 구분**:
        - **동기 처리**: `emit()` 호출 시 즉시 구독자에게 이벤트를 전달합니다.
        - **비동기 처리**: `process.nextTick()`, `setImmediate()`, 또는 `setTimeout(..., 0)` 등을 사용하여 이벤트 처리를 이벤트 루프의 다음 틱으로 넘겨 비동기적으로 처리합니다. 이는 현재 호출 스택을 블로킹하지 않도록 합니다.
        - **지연 처리**: 특정 시간(예: `setTimeout(..., delay)`) 이후에 이벤트를 처리하도록 스케줄링합니다.
    - **우선순위 큐 (선택 사항)**: 이벤트의 중요도에 따라 우선순위를 부여하여 처리 순서를 제어할 수 있는 큐를 추가로 고려할 수 있습니다.
        

---

## 💻 구현

### 📌 항목

- **Race Condition 발생 코드 구현**: `worker_threads`를 사용하여 공유 변수에 접근하는 코드를 작성하고, Race Condition이 발생하는 것을 시연합니다.
- **Race Condition 해결 코드 구현**: `Atomics` 또는 다른 동기화 기법을 사용하여 Race Condition을 해결하고, 해결 전후의 결과를 비교합니다.
- **`EventManager` 클래스 구현**: `Node.js EventEmitter`를 활용하여 `EventManager` 클래스를 구현하고, Singleton 패턴을 적용합니다.
- **`Publisher` 및 `Subscriber` 클래스/함수 구현**: `EventManager`와 연동하여 이벤트를 발행하고 구독하는 `Publisher`와 `Subscriber`를 구현합니다.
- **이벤트 큐 및 처리 로직 구현**: 동기, 비동기, 지연 처리 기능을 포함하는 이벤트 큐와 이를 관리하는 로직을 구현합니다.
- **테스트 케이스 작성**: 구현된 기능들이 올바르게 동작하는지 확인하기 위한 테스트 코드를 작성합니다.
</details>

예상보다 더 논리적으로 README.md를 작성해주어서 한 주간 README.md 작성에 작은 도움이 되었던 것 같습니다.

## QUEST2. AI를 활용한 학습 내용 검증

- 미션을 진행하면서 학습정리를 작성할 때 최대한 신뢰도 있는 자료를 찾으려고 노력하는데, 이 퀘스트를 수행하면 더 쉽게 좋은 자료를 찾고 검증까지 할 수 있을 것 같아 선정하게 되었습니다.

> 내가 아래처럼 파일 시스템에 대해 이해하고 정리했는데,

<details>
<summary>접기/펼치기</summary>

## ❓ 파일 시스템이란?

밑바닥부터 생각해본다면, 우리는 어떻게 하드디스크나 SSD에 데이터나 파일을 저장하고 읽을까?

하드디스크는 미세한 자성물질이 씌워진 원판을 회전시키며 미세한 단위의 자기 방향으로 그 정보를 기록한다. 또한 SSD는 그 이름인 Solid-State Drive와 같이, 회전하는 부품 없이 반도체만으로 정보를 0과 1의 전기적인 신호로 저장한다.

컴퓨터가 이런 보조기억장치의 정보를 읽어들이려면 하드웨어에서 인식한 전기적 정보를 어떻게 해석할 지, 어떤 크기로 입력을 나누어야 최소 단위가 될 지, 읽은 정보를 어떻게 읽어야 그것이 파일이고 그 파일의 정보를 의미하는 건지 많은 결정 기준을 내리고 처리해줄 무언가가 필요하다.

🔷 **파일 시스템**이란, **운영체제에서 파일이나 데이터를 규칙에 따라 효율적으로 하드웨어에 읽고, 쓰고, 검색하고 관리할 수 있도록 체계적으로 관리해주는 인터페이스 & 프로그램**이다. **OS의 커널 요소**로서, 파일 시스템은 물리적인 입력 정보를 해석해 사용자가 이해할 수 있는 파일 시스템 구조로 표현해준다.

각각의 OS마다, 호환이 가능한 파일 시스템이 다르다. Windows를 예시로 들어보면, Windows는 디스크 드라이브를 NTFS라는 파일 시스템 형태로 읽어 사용하는 것이 가장 호환성이 좋은 편이다.

파일 시스템은 저장장치와 사용자 사이에서 데이터를 처리하는 프로그램과 동시에 인터페이스로 동작한다. 특정 파일 시스템의 저장 형식으로 저장장치의 파티션이 구성되어 있다면, OS에서 동작하는 파일 시스템이 그 저장장치를 해당 파일 시스템 형식에 맞게 해석해 논리적으로 파일 시스템을 형성한다.

🔷 정리하면 다음과 같이 나타낼 수 있다.

- 파일 시스템은 물리적인 저장장치에 접근해 OS나 응용 프로그램들이 실제 물리적 데이터를 처리할 필요 없이 파일과 데이터를 다룰 수 있도록 해주는 인터페이스이다.
- 파일 시스템은 저장장치의 물리적 신호 바이트를 논리적인 파일 구조로 조직하고 나타내 우리가 파일과 디렉토리를 조작하면 그에 맞게 저장장치에서 읽고 쓰는 동작을 수행한다.
- OS의 커널에 **파일 시스템을 처리할 수 있는 프로그램**(드라이버)이 존재한다. 이 프로그램이 지원하는 파일 시스템 형식이 서로 다르기 때문에, OS 마다 지원 가능한 파일 시스템이 서로 다르다.
</details>

> 프롬프트 : 이 내용이 
> - IEEE 공식 문서 (ttps://pubs.opengroup.org/onlinepubs/9699919799/)
> - IBM 공식 문서 (https://www.ibm.com/docs/ko/aix/7.2.0?topic=tree-file-system-structure), 
> - Operation System Concepts 도서(https://www.mbit.edu.in/wp-content/uploads/2020/05/Operating_System_Concepts_8th_EditionA4.pdf)
> 위 제시한 공식 자료를 기준으로 정확한지 검증해 줘. 만약 틀리거나 빠진 내용이 있다면 알려줘.

<details>
<summary>접기/펼치기</summary>

### 검증 결과 및 보충/강조 내용

**1. "밑바닥부터 생각해본다면, 우리는 어떻게 하드디스크나 SSD에 데이터나 파일을 저장하고 읽을까?"**

- **정확성**: 하드디스크와 SSD의 물리적 저장 방식에 대한 설명은 간략하지만 정확합니다.
    
- **보충/강조**: 이 부분은 파일 시스템이 **물리적인 저장 매체의 특성과 논리적인 파일 구조 사이의 추상화 계층**임을 잘 보여주는 도입부입니다.
    

**2. "컴퓨터가 이런 보조기억장치의 정보를 읽어들이려면 하드웨어에서 인식한 전기적 정보를 어떻게 해석할 지, 어떤 크기로 입력을 나누어야 최소 단위가 될 지, 읽은 정보를 어떻게 읽어야 그것이 파일이고 그 파일의 정보를 의미하는 건지 많은 결정 기준을 내리고 처리해줄 무언가가 필요하다."**

- **정확성**: 파일 시스템의 필요성을 잘 설명하고 있습니다. 특히 "어떤 크기로 입력을 나누어야 최소 단위가 될 지" 부분은 파일 시스템이 데이터를 **블록(block) 단위**로 관리한다는 핵심 개념을 내포하고 있습니다.
    
- **보충/강조**: 이 "최소 단위"가 곧 "블록" 또는 "클러스터"이며, 파일 시스템은 이러한 논리적인 블록들을 물리적인 디스크 섹터에 매핑하는 역할을 수행합니다.
    

**3. "🔷 파일 시스템이란, 운영체제에서 파일이나 데이터를 규칙에 따라 효율적으로 하드웨어에 읽고, 쓰고, 검색하고 관리할 수 있도록 체계적으로 관리해주는 인터페이스 & 프로그램이다. OS의 커널 요소로서, 파일 시스템은 물리적인 입력 정보를 해석해 사용자가 이해할 수 있는 파일 시스템 구조로 표현해준다."**

- **정확성**: 파일 시스템의 정의를 매우 정확하게 설명하고 있습니다. "인터페이스 & 프로그램"이라는 표현은 추상화 계층으로서의 역할과 실제 구현체로서의 역할을 동시에 잘 나타냅니다. "OS의 커널 요소"라는 점도 중요합니다.
    
- **참고 자료 매칭**:
    
    - **Operating System Concepts (8th Ed., Chapter 10: File-System Interface, Chapter 11: File-System Implementation)**: 파일 시스템을 "파일을 저장하고 조직하는 방법"으로 정의하며, 사용자에게는 논리적인 저장 장치로 보이지만 실제로는 물리적인 디스크 블록에 매핑된다고 설명합니다. 또한, 파일 시스템은 OS의 중요한 컴포넌트이며, 커널의 일부로 구현된다고 명시합니다.
        
    - **IBM 공식 문서**: 파일 시스템이 데이터와 파일을 저장하고 조직하는 구조를 제공하며, 사용자에게 파일에 접근하는 방식을 추상화한다고 설명합니다.
        

**4. "각각의 OS마다, 호환이 가능한 파일 시스템이 다르다. Windows를 예시로 들어보면, Windows는 디스크 드라이브를 NTFS라는 파일 시스템 형태로 읽어 사용하는 것이 가장 호환성이 좋은 편이다."**

- **정확성**: OS마다 지원하는 파일 시스템이 다르다는 점과 Windows의 NTFS 예시는 정확합니다.
    
- **보충/강조**: 이는 파일 시스템이 **특정 OS에 종속적이거나 최적화될 수 있음**을 의미합니다. (예: Linux의 ext4, macOS의 APFS 등)
    

**5. "파일 시스템은 저장장치와 사용자 사이에서 데이터를 처리하는 프로그램과 동시에 인터페이스로 동작한다. 특정 파일 시스템의 저장 형식으로 저장장치의 파티션이 구성되어 있다면, OS에서 동작하는 파일 시스템이 그 저장장치를 해당 파일 시스템 형식에 맞게 해석해 논리적으로 파일 시스템을 형성한다."**

- **정확성**: 파일 시스템의 역할과 동작 방식을 명확하게 설명하고 있습니다. "논리적으로 파일 시스템을 형성한다"는 표현은 물리적 저장 공간 위에 추상화된 계층을 제공한다는 점을 잘 나타냅니다.
    
- **참고 자료 매칭**:
    
    - **Operating System Concepts**: 파일 시스템은 디스크의 물리적 특성을 추상화하여 사용자에게는 논리적인 데이터 저장소로 보이게 한다고 강조합니다. 디스크는 섹터들의 배열로 보이지만, 파일 시스템은 이를 파일과 디렉토리의 계층 구조로 매핑합니다.
        

**6. "🔷 정리하면 다음과 같이 나타낼 수 있다."**

- **첫 번째 항목**: "파일 시스템은 물리적인 저장장치에 접근해 OS나 응용 프로그램들이 실제 물리적 데이터를 처리할 필요 없이 파일과 데이터를 다룰 수 있도록 해주는 인터페이스이다."
    
    - **정확성**: **추상화 계층**으로서의 파일 시스템 역할을 잘 요약했습니다. 매우 중요한 포인트입니다.
        
- **두 번째 항목**: "파일 시스템은 저장장치의 물리적 신호 바이트를 논리적인 파일 구조로 조직하고 나타내 우리가 파일과 디렉토리를 조작하면 그에 맞게 저장장치에서 읽고 쓰는 동작을 수행한다."
    
    - **정확성**: **물리적-논리적 매핑**의 역할을 잘 설명했습니다. 파일과 디렉토리의 개념은 파일 시스템이 제공하는 핵심적인 논리적 구조입니다.
        
- **세 번째 항목**: "OS의 커널에 **파일 시스템을 처리할 수 있는 프로그램**(드라이버)이 존재한다. 이 프로그램이 지원하는 파일 시스템 형식이 서로 다르기 때문에, OS 마다 지원 가능한 파일 시스템이 서로 다르다."
    
    - **정확성**: 파일 시스템 구현이 **커널 내의 모듈 또는 드라이버 형태**로 존재한다는 점을 정확히 언급했습니다. 이는 앞서 "OS의 커널 요소"라는 설명과 일관됩니다.
        

### 빠지거나 보충할 수 있는 내용 (필수적이지는 않으나 이해를 심화시키는 데 도움)

- **메타데이터 (Metadata)**: 파일 시스템의 중요한 역할 중 하나는 파일의 내용뿐만 아니라 파일의 이름, 크기, 생성 날짜, 수정 날짜, 소유자, 접근 권한 등 파일에 대한 정보(메타데이터)를 관리하는 것입니다. 이 메타데이터는 파일 시스템이 파일을 효율적으로 찾고, 관리하며, 접근을 제어하는 데 필수적입니다.
    
- **디렉토리 구조 (Directory Structure)**: 파일 시스템은 일반적으로 계층적인 디렉토리 구조(트리 구조)를 사용하여 파일을 조직합니다. 이는 사용자가 파일을 논리적으로 분류하고 쉽게 탐색할 수 있도록 돕습니다. (IBM 문서는 "tree-structured file system"을 명시)
    
- **파일 시스템의 핵심 기능**:
    
    - **파일 생성 및 삭제 (Create/Delete)**
        
    - **파일 읽기 및 쓰기 (Read/Write)**
        
    - **파일 열기 및 닫기 (Open/Close)**
        
    - **파일 위치 탐색 (Seek)**
        
    - **디렉토리 생성 및 삭제 (Create/Delete Directory)**
        
    - **디렉토리 내용 나열 (List Directory)**
        
- **일관성 및 신뢰성**: 파일 시스템은 시스템 크래시나 전원 장애 시에도 데이터의 일관성과 무결성을 유지하려는 메커니즘을 가집니다 (예: 저널링 파일 시스템). 이 부분은 고급 주제지만, 파일 시스템의 중요성을 더욱 부각시킬 수 있습니다.
    
- **블록 할당 (Block Allocation)**: 파일 시스템은 파일의 데이터를 저장 장치의 블록들에 어떻게 할당할지 결정합니다. 연속 할당, 연결 할당, 색인 할당 등의 방법이 있습니다.
    

### 결론

제시해주신 파일 시스템에 대한 내용은 **매우 정확하고 핵심적인 개념들을 잘 정리**하고 있습니다. IEEE, IBM, Operating System Concepts 도서의 내용을 충실히 반영하고 있으며, 파일 시스템의 본질적인 역할과 필요성을 명확하게 설명합니다. 위에서 제시한 보충 내용들은 이해를 더욱 심화시키기 위한 추가적인 관점이며, 현재 정리된 내용만으로도 파일 시스템에 대한 기본적인 이해를 갖추는 데 전혀 문제가 없습니다.

</details>

검증 내용 중, AI가 내리는 평가에 대해서는 잘 모르겠으나 내가 정리한 내용과 공식 문서의 내용을 찾아서 서로 매칭해 주는 것은 내가 정리한 게 맞는 방향인지의 신뢰도 확보에 있어서 꽤 도움이 되었습니다.
