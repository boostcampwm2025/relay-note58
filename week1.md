## 과제 진행 중 AI 사용

### 정리

- AI 를 통해 학습 정리를 자동화해 학습과 구현을 위한 시간으로 사용한다.

### 학습

- 공식 문서와 신뢰도 높은 자료를 기반으로 학습하기 위해 AI를 사용힌다.
- 학습한 내용을 검증하고 교정하기 위해 사용한다.
- 꼬리 질문을 통해 깊이있게 학습하기 위해 사용한다.

### 설계(구현)

- 본인의 힘으로 요구사항을 분석하고 설계하는 것에  집중한다.
- 미션이 진행이 되지 않을 만큼 막히는 상황에 물꼬를 트는 역할로만 활용한다.

[README.md](https://www.notion.so/README-md-23421d5bf78e80d596d7fefe02a7dc90?pvs=21)

`weekN.md`

# 부스트캠프 AI 활용 가이드

**부스트캠프 커뮤니티 및 개발자로서의 성장**을 위해 AI를 어떻게 활용할 수 있는지를 공유하고, 실질적인 도구 활용 방안을 토의함

---

## ✨ 목적

- AI 도구를 활용한 **개인의 성장 및 학습 효율화**
- 팀원 간의 **지식 공유 및 협업 강화**
- 반복되는 학습과 피드백을 **자동화 및 구조화**

---

### **토론으로 나온 주제들**

📝 문서 작성 및 정리

- README.md 자동 생성
- 학습 내용 검증

💬 커뮤니티 활성화

- ~~Slack Random 채널 질문 생성~~

🔄 자동화 도구

- ~~체크포인트 자동화~~

📚 학습 도우미

- ~~대화 내용 문서화~~
- ~~NotebookLM 활용~~

🔍 피드백 시스템

- 클로바를 통한 ****피어 피드백 사전점검

---

## QUEST1. README.md 자동 생성

- 퀘스트를 제작한 배경과 이유
    - 많은 프로젝트가 **문서화의 중요성**을 알면서도, 바쁘다는 이유로 `README.md` 작성을 소홀히 하거나 매번 다른 형식으로 작성합니다. 이는 미래의 나 자신 또는 새로운 팀원이 프로젝트를 파악하는 데 드는 비용을 증가시킵니다. 이러한 **수동 작성의 번거로움을 해결**하고, 누구나 쉽고 빠르게 표준화된 문서를 만들 수 있도록 돕기 위해 이 퀘스트를 제작했습니다.
- 목적과 달성 기준
    - **자동화 도구나 AI 프롬프트**를 활용하여, 자신의 프로젝트(개인/팀) 중 하나에 `README.md`를 **생성 또는 개선**

### **1. 나만의 README 템플릿 정의하기**

먼저, 앞으로 계속 사용하고 싶은 자신만의 README 구조를 만듭니다. 이것이 AI에게 전달할 '지시사항'이 됩니다. 마크다운 형식으로 정리해주기.

**[나만의 템플릿 예시]**

```
# 🚀 [프로젝트 이름]

> [프로젝트 한 줄 요약]

## 🛠️ 설계과정

## ✨주요기능

- [기능 1]
- [기능 2]
- [기능 3]
```

### 2.  README에 들어갈 내용 자유롭게 작성하기

### 3. 프롬포트 실행하기

**예시**

<aside>
🗣

너는 숙련된 개발자이고, 프로젝트 문서를 아주 잘 작성하는 전문가야.
아래의 [템플릿 양식]에 맞춰서, [내가 작성한 내용]을 정리해 완벽한 [README.md](http://readme.md/) 파일을 마크다운 형식으로 만들어줘.

</aside>

---

## QUEST2 . AI를 활용한 학습 내용 검증

- 배경과 이유
    - 블로그나 단편적인 정보에 의존하기보다, 공식 문서와 신뢰도 높은 자료를 기반으로 학습하고 AI를 활용해 내가 아는 것을 끊임없이 검증하고 교정하기 위함.
- 목적과 달성 기준
    - 최근 학습한 기술 개념이나 코드에 대해 **자신이 이해한 내용을 먼저 정리**합니다.
    - AI에게 **"이 내용이 공식 문서를 기준으로 정확한지 검증해 줘"**와 같은 프롬프트를 사용하여 검증을 요청하고, 그 답변을 받습니다.

### **1. 내가 학습한 내용 정리하기**

가장 먼저, 블로그나 다른 자료를 통해 학습한 내용을 **자신만의 언어로 요약**. 코드 예제, 핵심 개념, 동작 방식 등을 간단하게 정리합니다. 이 내용이 AI에게 검증을 요청할 '원본'

### **2. 공식 문서 또는 신뢰할 만한 자료 찾기**

검증의 기준이 될 **공식 문서**나 그에 준하는 신뢰도 높은 자료(예: MDN Web Docs)를 찾습니다. 보통 '기술 이름 + official docs'로 검색하면 쉽게 찾을 수 있습니다.

또는

**가장 신뢰도 높은 자료 추천 요청하기**

> "자바스크립트의 async/await에 대해 공부하려고 해. MDN이나 공식 문서처럼 가장 신뢰할 수 있는 자료 링크 몇 개만 추천해 줘."
>

### **3. AI에게 '비교 및 검증' 요청하기**

이제 AI에게 **1번**에서 정리한 내용과 **2번**에서 찾은 공식 문서를 함께 제공하며, 구체적으로 검증을 요청

**질문예시**

<aside>
🗣

```
내가 아래처럼 JavaScript Map과 일반 객체에 대해 이해했는데,
이 내용이 Javascript 공식 문서를 기준으로 정확한지 검증해 줘.
만약 틀리거나 빠진 내용이 있다면 알려줘.

JavaScript에서는 Map과 일반 객체(Object)가 모두 키-값 쌍을 저장하는 자료구조로 사용될 수 있지만,
몇 가지 중요한 차이점이 있습니다. Map은 키의 종류 제한이 없고, 반복 가능하며, 크기 관리가 용이한 반면,
일반 객체는 문자열 또는 Symbol만 키로 사용할 수 있고, 크기 확인이 복잡하며, 
예측 불가능한 동작을 할 수 있다.
```

</aside>

## QUEST3.  클로바를 이용한 **피어 피드백 사전점검**

- 배경
    - 피어 피드백을 진행하면서 본인의 의도와 생각을 말로 표현하기 어려웠던 경험이 있습니다. 그리고 말하는 스킬을 부족하다는 생각이 들 때도 있습니다... 그래서 피어 피드백 전 사전점검과 연습을 제안합니다.
- 목적과 달성기준
    - 발표 전 연습 과정을 통해 본인의 의도와 메시지가 동료들에게 명확히 전달되는지 객관적으로 점검하고, 말하기 스킬의 강·약점을 파악하여 자신감을 가지고 피어 피드백에 임할 수 있도록 준비합니다.
    - 피드백 반영 및 점검
        - 도출된 개선사항을 반영해 수정하고 재연습을 통해 전달력(명확성·간결성)이 향상되었음을 스스로 확인합니다.

### 1. clovanote로 발표 연습 과정을 녹음해보세요.

### 2. clovanote에서 텍스트 파일을 추출합니다.

### 3. chatGPT GPTs 중  `Communication Coach` 을 활용하여 피드백을 진행합니다.

<img width="523" height="879" alt="coach" src="https://github.com/user-attachments/assets/92fb3d4a-dd5c-42f7-a4f7-5042b7488428" />

### 4. 피드백 내용을 적용하여 피어 피드백을 진행해봅니다.

+) 제공되는 프롬프트를 활용해보세요! (원하는 방향으로 수정하거나 새로 만드셔도 됩니다)

```jsx
# 역할 설정
당신은 ‘경력 10년 차 커뮤니케이션 코치’이자 개발자입니다.

# 입력 데이터
아래는 곧 동료들 앞에서 발표할 스크립트(발표 원고)입니다.  
<여기에 발표 스크립트 텍스트 붙여넣기>

# 분석·피드백 요청 사항
1. **발표 목적 확인**  
   - 이 스크립트가 달성하려는 목표(정보 전달, 의견 수렴 등)가 잘 드러나는지 평가해주세요.

2. **구조 및 흐름 검토**  
   - 도입부, 본문(주요 메시지 전개), 결론으로 자연스럽게 이어지는지  
   - 각 섹션 간 전환(Transition)이 부드러운지

3. **핵심 메시지 명확성**  
   - 중요한 포인트가 청중에게 명확히 전달되는지  
   - 메시지별 강조·반복이 적절한지

4. **설득력·흥미 요소**  
   - 예시, 데이터, 스토리텔링 등 청중의 관심을 끌 수 있는 요소가 충분한지  
   - 질문·호소 전략(“~라고 생각해 보셨나요?” 등)이 효과적인지

5. **언어 스타일 및 어휘 선택**  
   - 전문성과 친근함의 균형이 적절한지  
   - 불필요하게 긴 문장·모호한 표현이 없는지

6. **개선 제안 3가지**  
   - 구체적으로 수정하거나 덜어내면 좋을 부분  
   - 더 강조·생략·재배치하면 좋을 문장

7. **실전 적용 팁 3가지**  
   - 목소리 톤·속도 조절  
   - 핵심 메시지 강조를 위한 제스처나 페이스 페이싱  
   - 리허설 시 체크할 포인트

# 출력 형식
1) 발표 목적  
2) 구조 및 흐름 피드백  
3) 핵심 메시지 피드백  
4) 설득력·흥미 요소 평가  
5) 언어 스타일 코멘트  
6) 시간 분량 코멘트  
7) 개선 제안 3가지  
8) 실전 적용 팁 3가지

```

## QUEST4.  **AI를 통한 집중력 확인해보기**

- 배경과 이유
    - 자신이 정한 학습테스크는 확실하게 끝내고 오자 !
      많은 과제를 해결하면서 집중력이 많이 흐려지는 우리 캠퍼 분들 .. 하지만 그래도 집중하셔야합니다 !
- 목적과 달성 기준
    - 자신의 학습테스크에서는 최대한 집중할 수 있게 하자 !
    - 과제가 어렵다고 집중력이 끊이는 경우가 되게 많아진다.

**AI 집중력 확인 시스템 가이드**

이 문서는 'AI 집중력 확인 시스템'의 사용법을 안내합니다. 일반 사용자를 위한 **[실제 사용 가이드]**와 개발 및 수정을 위한 **[코드 사용 가이드]**로 구성되어 있습니다.

**1. 실제 사용 가이드 (End-User Manual)**

이 가이드는 프로그램의 기능과 사용법을 설명합니다.

**시작하기**

1. **프로그램 열기**: `index.html` 파일을 크롬(Chrome)과 같은 웹 브라우저로 엽니다.
2. **카메라 권한 허용**: 화면 상단에 나타나는 카메라 접근 권한 요청 창에서 **"허용"**을 클릭해야 합니다. 이 권한이 없으면 시스템이 작동하지 않습니다.
3. **상호작용**: 알람 소리가 정상적으로 작동하려면, 페이지가 열린 후 **화면의 아무 곳이나 한 번 클릭**해주세요.

**화면 구성**

- **원본 웹캠**: 카메라에 비치는 당신의 모습이 실시간으로 보이는 화면입니다.
- **분석 영상**: AI가 당신의 얼굴 특징점을 어떻게 추적하고 있는지 시각적으로 보여주는 화면입니다.
- **현재 상태**: 시스템이 판단한 당신의 집중 상태가 글자로 표시됩니다.

**상태의 종류와 기준**

시스템은 당신의 상태를 4가지로 판단하며, 각 상태의 기준은 다음과 같습니다.

| **상태** | **기준** | **설명** |
| --- | --- | --- |
| **✅ 집중** | 다른 모든 상태가 아닐 때 | 시스템이 판단하는 가장 이상적인 상태입니다. |
| **⚠️ 주의 분산** | 머리 각도 이탈 | 머리가 좌우 또는 상하로 일정 각도 이상 돌아간 상태가 감지될 때입니다. |
| **😴 졸음** | 눈 감김 감지 | 눈을 감고 있거나 게슴츠레하게 뜨고 있는 상태가 감지될 때입니다. |
| **💨 자리 비움** | 얼굴 미감지 | 화면에서 당신의 얼굴을 찾을 수 없을 때입니다. |

**주요 기능: 알림**

- **알림 조건**: '주의 분산' 또는 '졸음' 상태가 **총 2분 이상 지속**되면 알림이 울립니다. 다시 '집중'하면 타이머는 초기화됩니다.
- **알람 소리 변경**: 화면 하단의 파일 선택 버튼을 눌러 원하는 오디오 파일(MP3, WAV 등)을 알람으로 설정할 수 있습니다. 설정하지 않으면 기본 '삐' 소리가 나옵니다.

**정확도 높이는 팁**

- **조명**: 얼굴 전체가 밝게 보이는 정면광 환경에서 가장 잘 작동합니다.
- **카메라 위치**: 카메라는 당신의 눈높이에 맞춰 정면에 두는 것이 좋습니다.

* 자신의 학습 테스크가 끝나기 전까지 알람이 오지 않으면 성공 !

## **코드 수정 가이드**

- **민감도 조절**:
    - '주의 분산'이 너무 자주 뜬다면 **`YAW_THRESHOLD`**, **`PITCH_THRESHOLD`** 값을 **늘리세요.**
    - '졸음'이 너무 자주 뜬다면 **`EAR_THRESHOLD`** 값을 **줄이세요.**
    - 상태 변경이 너무 늦거나 빠르다고 느껴지면 **`HISTORY_SIZE`** 값을 조절하세요. (값을 늘리면 더 둔감하게, 줄이면 더 민감하게 반응)

---

# 퀘스트 수행

## J162

QUEST1. README.md 자동 생성
QUEST4. AI를 통한 집중력 확인해보기

- 이번주에 미션을 할 때마다 README을 어떻게 구성해야할까가 떠오르지않아 2시에 가깝게 제출을 했었기에 형식이 없고 설명하는데에도 어려움이 있었습니다. REAMDE 자동 생성을 사용하면 가독성 좋게 README를 제작할 수 있을 것 같습니다

- 미션이 진행되면서 수요일부터는 집중력이 확실히 떨어진다는 느낌을 받았기에 AI로 집중력 테스트를 해보면서 재미요소를 챙기며 미션을 해결하고자 선택했습니다.

### README.md 자동 생성
입력
> 매일 프로그래밍 미션을 수행하고 과정을 README에 기록해야해 내가 정리한 내용을 아래 템플릿에 맞춰서 README.md를 작성해줘
```
1. 요구사항 분석
기능	설명
예시	기능 설명 작성

2. 설계 과정
디렉토리 구조

주요 데이터 구조

로직 흐름 요약 (입력 → 처리 → 출력)

3. 구현 과정
메서드1: 메서드명
간단한 설명

주요 동작 요약

메서드2: 메서드명
간단한 설명

주요 동작 요약

4. 단위 테스트
사용 도구 (ex. Jest)

주요 테스트 항목 및 검증 방식

```
출력

```
프로젝트명: 가상 파일 시스템 (Virtual File System)
📌 1. 요구사항 분석
항목	기능 설명
CLI 제공	사용자 입력을 받아 명령어 실행
초기화 (init)	최대 크기 설정, 루트 디렉토리 / 생성
디렉토리 생성 (makedir)	현재 디렉토리 하위에 새 디렉토리 생성
텍스트 파일 생성 (create)	내용 포함된 .txt 파일 생성
디렉토리 내용 조회 (list)	하위 파일/디렉토리 목록 출력
텍스트 파일 읽기 (read)	파일 경로를 통해 파일 내용 출력
파일 가져오기 (import)	실제 파일 시스템의 파일을 VFS로 가져오기
파일 내보내기 (export)	VFS 내 파일을 실제 파일 시스템에 저장
영속성	종료 후에도 파일 구조 및 내용 유지
바이너리 파일 지원	텍스트 외 이미지 등 포맷도 처리 가능

...

```

### 집중력 확인해보기

<img width="1032" height="785" alt="image" src="https://github.com/user-attachments/assets/67a8a00d-97f6-4173-b9ef-6a8414bbcf43" />

## S022

<details>
<summary><b>정리</b></summary>

### 선택한 퀘스트와 그 이유

> [!NOTE]
> 퀘스트 1. README.md 자동생성  

이미 스스로의 README 템플릿을 구축한 상태였습니다. 하지만 매번 구현하기 바쁘다, 학습하기 바쁘다란 이유로 만들어놓은 템플릿에 따르지 않고 형식이 바뀌곤 했습니다.  

따라서 이 퀘스트를 수행하여 팀원들이 저장소를 파악하는 데 드는 시간과 피로를 줄이며,  

최종적으로 효율적인 문서화 역량을 기르고자 선택했습니다.  

---

> [!NOTE]
> 퀘스트 2. AI를 통한 집중력 확인해보기

문제를 수행하면서 필연적으로 집중력 저하와 졸음이 밀려옵니다.  
제 스스로가 정한 학습 테스크인 체크포인트를 수행할 때는 최대한 집중하고자 합니다.  
한 번씩 집중력이 끊기는 것을 방지하고, 문제에 더 집중하고자 합니다.  

## 퀘스트 수행 기록

### 1. README 자동 생성

<details>
<summary><b>정리</b></summary>

#### 📌 프롬프트

```bash
어떤 문제가 주어졌을 때, 학습-설계-구현의 과정이 잘 드러나도록 README에 기록해야해.

아래 마크다운 서식은 내가 기본적으로 사용하는 템플릿이야.
어떤지 판단해줘

# Day N. 문제 이름

## 분석

### 전략 세우기

### 문제 의도 파악하기

## 설계

### 흐름 정리

### 데이터 구조 설계

### 구현 순서

## 구현

### 구현 과정 1

### 구현 과정 2

## 결과
```

#### 📌 답변

```bash
아주 좋은 템플릿입니다. 아래와 같이 장점과, 조금 더 효과적으로 활용할 수 있는 피드백을 남겨드립니다.

---

학습 → 설계 → 구현의 흐름이 명확하게 구분되어 있습니다.

분석 파트에서 문제의 의도와 전략을 먼저 고민하도록 유도하여, 무작정 구현하기 전에 문제의 본질을 생각할 수 있게 합니다.

설계 파트에서 흐름, 데이터 구조, 구현 순서를 분리하여 설계의 구체성과 실행 가능성을 높였습니다.

구현 파트에서 과정을 단계별로 기록함으로써, 회고나 리팩터링 시 참고하기 좋습니다.

마지막 결과 파트에서 실제 실행 결과와 학습 내용을 남길 수 있습니다.

---
더 개선하면 좋은 점 (선택)

회고/피드백 섹션을 마지막에 추가하면, 구현하면서 느낀 점, 아쉬운 점, 다음에 보완할 점 등을 간단히 남길 수 있습니다.

문제 정의나 핵심 요구사항 요약 등, 분석 전에 “문제 요약”을 한 줄 넣는 것도 초심자에겐 도움이 됩니다.

이슈/트러블슈팅 란(구현 과정 중 문제와 해결방법)을 중간에 둘 수도 있습니다.
```

AI가 답변해준 내용에 `회고/피드백` 섹션을 추가하라는 의견이 있었습니다.  

정말 좋은 생각인 것 같아서 즉시 적용을 한 뒤 이번주에 활용했습니다.

REAMD 마지막 세션에 `일일 회고` 세션을 하나 추가해 그 날의 느낀점, 문제를 풀며 느낀점 등을 정리하니 더욱 기억에 남는 문제 풀이 시간이었던 것 같습니다.

</details>

### 2. AI를 통한 집중력 확인해보기

<details>
<summary><b>정리</b></summary>

이번 주 `월요일`, `화요일`에 해당 사이트를 활용하며 문제를 풀었습니다.  

평소 `플레이리스트`를 백색소음 삼아 문제를 풀었는데 그 버릇대로 소리를 최대로 켜놓고 하니 심장이 멎을 뻔한 게 한두 번이 아니었습니다.

따로 코드를 수정해 커스터마이징할 수 있었지만, 따로 수정하지 않고 제공된 서비스를 온전히 사용했습니다. 

확실히, 졸거나 집중력이 흐트러질 때 효과가 되게 좋았습니다.  

다만, 웹 사이트 기반이다 보니 다른 탭과 겹쳐 저도 모르게 종료해 버리는 경우가 너무 많았습니다. 그래도 돌이켜보면 `AI를 통한 집중력 확인해 보기` 퀘스트엔 충실히 임했고, 실제 도움도 많이 받았다는 생각이 듭니다. 

남은 챌린지 기간에서도 자주 사용할 것 같습니다.

</details>
</details>


## J280

## 🎯 선택한 퀘스트
- **Quest1** : README.md 자동 생성  
- **Quest4** : AI를 통한 집중력 확인해보기  

---

## ✨ 선택한 이유

### Quest1: README.md 자동 생성
1. 평소에 `README.md` 작성이 어렵다고 느꼈기 때문에 이번 기회에 **효율적인 작성 방식**을 찾아보고 싶었습니다.
2. 자동화 도구나 AI를 활용하여 **꾸준히 사용할 수 있는 나만의 템플릿**을 만들어, 이후 프로젝트에 적용하고자 선택했습니다.
3. 퀘스트를 계기로 리드미 작성의 **형식과 규칙을 정의**하고 싶었습니다.

### Quest4: AI를 통한 집중력 확인해보기
1. 퀘스트를 너무 열심히 준비해주신 것이 느껴졌고, 설명이 **재미있고 흥미로워 보여서 선택**하게 되었습니다.
2. **재미와 스릴이 가미된 활동이라면 힘든 공부도 조금 더 수월하게 느껴질 것** 같다고 생각했습니다.
3. 공부를 할 때 가끔 이런 **가벼운 흥미 요소가 동기 부여에 도움이 된다고 느껴** 선택하게 되었습니다.

---

## 🔧 수행 과정

### Quest1: README.md 자동 생성

#### 🚀 수행 방법
- 바로 마지막 day9 미션에서 완성한 코드를 토대로 README 작성을 이용하기로 결정하였다.
- GPT를 이용했고 아래 프롬프트 2개와 코드를 복사해주었다.
- 프롬프트 1
  ```prompt
  너는 숙련된 개발자이고, 프로젝트 문서를 아주 잘 작성하는 전문가야. 아래의 [템플릿 양식]에 맞춰서, [내가 작성한 내용]을 정리해 완벽한 README.md 파일을 마크다운 형식으로 만들어줘.

  # 🚀 스레드 레이스

  > 학습 키워드

  ## 🛠️ 설계과정

  ## ✨주요기능

  - [기능 1]
  - [기능 2]
  - [기능 3]
  ```
- 프롬프트 2
  ```prompt
  학습 키워드는 > #IPC, #레이스 컨디션 #멀티 스레드야 ㅜㅜ 그리고 내 코드를 더 줄게! 코드의 주요 함수나 기능에 대한 설명도 해줬으면 좋겠어.
  [코드1]
  [코드2]
  ```

#### ✅ 결과
<details>
<summary>최종 생성된 README.md 파일</summary>

# 🚀 스레드 레이스

**멀티스레드 환경에서의 작업 분배, 경쟁 상태(Race Condition), 락(Lock) 처리, IPC(프로세스 간 통신)** 등을 학습하고 시뮬레이션하는 Node.js 기반 프로젝트입니다.

> **학습 키워드**  
> `멀티스레딩` `Worker Threads` `SharedArrayBuffer` `Atomics` `Lock` `Race Condition` `IPC` `스레드 스케줄링`

---

## 🛠️ 설계 과정

- `worker_threads` 모듈을 활용해 메인 스레드와 워커 간 병렬 처리 구조를 설계
- 공유 자원(`balance`)을 안전하게 조작하기 위해 `SharedArrayBuffer` + `Atomics` 기반의 락 메커니즘을 구현
- 워커는 역할 기반(`deposit`, `withdraw`, `inquiry`)으로 분기되어 작업 요청 및 수행을 반복
- IPC 통신은 `parentPort.postMessage()`와 `.on('message')`로 구성
- 각 워커는 작업이 없으면 요청을 재시도하며, 모든 작업이 끝나면 순차적으로 종료

---

## ✨ 주요 기능

- ✅ **역할 기반 워커 생성 및 분리된 작업 처리**
- `deposit`, `withdraw`, `inquiry` 역할의 워커들이 생성되고 자신에게 맞는 작업만 수행

- ✅ **공유 자원 보호**
- `SharedArrayBuffer`와 `Atomics.compareExchange()` 기반의 락 구현
- 레이스 컨디션 없이 잔액(balance)을 안전하게 입출금

- ✅ **스레드 간 IPC 통신 구현**
- 메인 스레드와 워커가 메시지를 통해 작업 요청, 로그 전달, 종료 신호 등을 주고받음

- ✅ **랜덤 딜레이 + 비동기 처리**
- 각 작업은 `setTimeout` 기반의 비동기 랜덤 지연을 포함해 현실성 있는 처리를 모방

---

## 📁 프로젝트 구조 예시

```
📦 thread-race/
┣ 📜 main.js         # 메인 스레드 - 작업 생성 및 워커 관리
┣ 📜 worker.js       # 워커 스레드 - 역할 기반 작업 처리
┣ 📜 README.md       # 프로젝트 소개 및 문서
```

---

## 🧠 주요 함수 설명

### 🔧 main.js

| 함수/이벤트 | 설명 |
|-------------|------|
| `new Worker()` | 역할별 워커를 생성하고 `shared` 버퍼 전달 |
| `worker.on('message')` | 워커로부터 로그, 요청, 완료 등의 메시지를 수신 |
| `worker.postMessage({ type: 'task' })` | 워커에게 작업 전달 |
| `worker.postMessage({ type: 'terminate' })` | 모든 작업이 완료되면 워커 종료 신호 전송 |
| `sharedView[0]` | 락 인덱스 (LOCK_INDEX) |
| `sharedView[1]` | 잔액(balance) 저장소 (BALANCE_INDEX) |

---

### 🔧 worker.js

| 함수 | 설명 |
|------|------|
| `acquireLock()` | 락이 0일 때만 점유, 아니면 대기 (`Atomics.wait`) |
| `releaseLock()` | 락 해제 후 대기 중인 스레드 깨움 (`Atomics.notify`) |
| `log(msg)` | 로그를 메인 스레드로 전송하며 타임스탬프 포함 |
| `deposit()` | 랜덤 금액 입금, 락으로 보호된 공유 자원 접근 |
| `withdraw()` | 랜덤 금액 출금, 부족 시 `insufficient balance` 출력 |
| `inquiry()` | 잔액 조회 후 로그 출력 |
| `parentPort.on('message')` | 메인으로부터 작업(task) 또는 종료(terminate) 메시지 수신 |

---

## ✅ 실행 예시 (콘솔 로그)

```
tasks: [ 'deposit', 'withdraw', 'inquiry', ... ]
[워커 준비 완료] threadId: 2, 역할: deposit
[워커 준비 완료] threadId: 4, 역할: inquiry
(15:03:12.123) [2] deposited 430
(15:03:12.834) [4] 현재 잔액 : 430원
(15:03:13.542) [3] withdraw 210
...
모든 worker가 종료되었습니다.
최종 공유 자원 값 (balance): 1270원
```

---

## 📌 학습 포인트 요약

| 항목 | 설명 |
|------|------|
| 🧵 멀티스레딩 | Node.js의 `worker_threads` 기반 워커 병렬 처리 |
| 🔐 동기화 제어 | Atomics로 구현한 락 처리로 공유 자원 보호 |
| 💬 IPC | 메인-워커 간 메시지 기반 통신 구조 |
| ⚠️ 레이스 컨디션 | 락 없이는 발생할 수 있는 Race Condition 직접 시뮬레이션 가능 |


---

## 🧠 참고 자료

- [Node.js 공식 문서: worker_threads](https://nodejs.org/api/worker_threads.html)
- [MDN Web Docs: Atomics](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics)
</details>

- 일단, README를 작성하는 시간을 많이 생각할 수 있었고, 이모티콘을 활용해 보기에 더 이쁜 문서를 작성할 수 있었다.

#### 💭 느낀 점
- 인공지능이 생각보다 내 코드 전반을 잘 이해하고, 틀을 주면 거기에 맞춰서 쓰는 능력은 꽤 수준급이라고 생각되었다. 다만 출처같은 건 내가 참고하지 않았는데도 함부로 붙여오는 경향을 보아 거짓말을 하는 점은 잘 안 고쳐지는 듯하다. ㅎㅎ

- 그래도 README를 너무 GPT에게 전반적으로 맡기는 것은 다른 분들이 보기에도 성의가 없어보이고 내가 의도한 바를 온전히 전달하는데는 좋지 않다고 생각되어 자주 사용하지는 못할 것 같다.

---

### Quest4: AI를 통한 집중력 확인해보기

#### 🚀 수행 방법
- 일단 사용 방법대로, 카메라를 눈높이에 맞춘 뒤에 정자세를 유지하며 사용하게 되었다. 또한 미션 내내(최소 10시간) 하라는 것은 아니겠지 싶어 내가 체크리스트에 분리해놓은 task 중 하나를 수행하는 동안 통과하는 것을 목표로 삼았다. 또, 모니터를 여러 개 사용하면 고개를 돌리는 것에 제약이 생겨 하나의 모니터만 사용할 수 있었다.
#### ✅ 결과
- 집중 유지 시간은 1시간 이상이었던 것 같고, 알람 기능은 활성화되지 않아서 일일이 집중되고 있는지 확인하며 체크하였다. 체크한 바로는 계속 집중이었고 생각보다 오랜 시간 동안 자리도 못 뜨고 정자세를 유지하느라 허리와 목이 많이 뻐근했다.
- 장난스러운 미션이라고 생각했는데 생각보다 큰 챌린지가 되었었다.

#### 💭 느낀 점
- 집중력에는 당연히 도움이 되었다. 이 작업을 빨리 끝내고 미션을 완수하고 싶었기에 정말 최선을 다해 노력해보았던 것 같다! 다만.. 미션 단위로 하기보다는 내가 한 자리에 정자세를 유지하고 싶은 최대 시간을 설정하고 그 시간 동안 실행하는 것이 바람직한 것 같다. 한 작업이 그렇게 짧지 않은 시간 동안 진행될 수도 있기 때문에 고문이 될 수도 있다.

---

## J268

---

## QUEST1. README.md 자동 생성

- README.md를 작성하지 않은 리포지토리를 무슨 내용인지 한눈에 파악이 가능할 것 같기 떄문에 선정하게 되었습니다.
- 추가적으로 파일을 업로드할 수 있는 AI 에이전트에서 작성한 코드까지 검토해 README.md를 작성해봐도 좋을 것 같습니다.

**README 템플릿**

## 개요

- 항목

## 📝 요구사항 분석

### 기능 및 구현

- 항목

### 테스트

## 📐 설계

### 📌 항목

## 💻 구현

### 📌 항목

---

**만들어 준 README.md**

<details>
<summary>접기/펼치기</summary>

## 개요

이 프로젝트는 Node.js 환경에서 **동기/비동기 처리**, **멀티 스레딩**, **Race Condition 관리**, 그리고 **발행-구독(Publisher-Subscriber) 패턴**의 심층적인 이해와 구현을 목표로 합니다. 특히, Node.js의 이벤트 루프 동작 방식과 멀티 스레드 환경에서의 효율적인 이벤트 관리 및 데이터 동시성 문제를 해결하는 방법에 중점을 둡니다.

## 📝 요구사항 분석

### 기능 및 구현

- **동기/비동기 개념 학습**: Node.js의 동작 방식 및 비동기 처리를 위한 Event Loop 메커니즘을 이해합니다.
- **프로세스, 스레드, 코루틴 학습**: 각 개념의 차이점과 동작 방식을 파악합니다.
- **멀티 스레드 동작 및 활용 조건**: 멀티 스레드가 어떻게 동작하며, 활용하기 위한 전제 조건을 학습합니다.
- **CPU 스케줄링 학습**: 비동기 작업을 CPU가 효율적으로 처리하도록 할당하는 스케줄링 방식을 이해합니다.
- **공유 영역 동시 접근 문제 처리**: 공유 자원에 동시에 접근할 때 발생하는 문제와 해결 방안을 학습합니다.
- **이벤트 처리 방식 학습**: 이벤트 발생 시 이를 처리하는 다양한 방식을 이해합니다.
- **디자인 패턴 학습**: Publisher-Subscriber 패턴과 Observer 패턴의 차이점, 구현 방법, 그리고 Singleton 패턴의 적용 이유를 학습합니다.
- **메시지 큐 학습**: 메시지 큐의 개념과 이벤트를 처리하는 방법을 이해합니다.

---

## 📐 설계

### 📌 멀티 스레드 Race-condition

- **멀티 스레드 환경 설정 도구 선정**: Node.js의 `worker_threads` 모듈을 활용하여 멀티 스레드 환경을 구성합니다.
- **Race-condition 발생 설계**: `worker_threads`를 사용하여 여러 스레드가 동시에 공유하는 변수(예: 카운터)에 접근하여 값을 증가시키는 작업을 수행하도록 설계하여 의도적으로 Race Condition이 발생하도록 합니다.
- **Race-condition 처리 기준 및 설계**:
    - **처리 기준**: Race Condition으로 인한 데이터 불일치 문제를 해결하고, 공유 자원의 일관성을 보장하는 것을 목표로 합니다.
    - **설계**:
        - **Mutex/Semaphore**: 상호 배제(Mutex) 또는 세마포어(Semaphore)와 같은 동기화 메커니즘을 사용하여 공유 자원에 대한 접근을 제어합니다. Node.js `worker_threads`에서 제공하는 `Atomics` 객체를 활용하거나, 별도의 락(Lock) 구현을 고려합니다.
        - **메시지 패싱**: 공유 메모리를 직접 조작하는 대신, 스레드 간 메시지 패싱을 통해 데이터를 교환하여 Race Condition의 발생 가능성을 줄입니다.
            
### 📌 멀티 스레드 환경에서의 발행-구독 패턴을 구현하는 이벤트 매니저

- **Node.js EventEmitter를 사용한 Publisher-Subscriber 패턴 구현 요소 설계**:
    - **Publisher**: 이벤트를 생성하고 `EventManager`에 해당 이벤트를 발행하는 역할을 수행합니다. `EventEmitter` 인스턴스를 내부적으로 사용하여 이벤트를 발행합니다.
    - **Subscriber**: `EventManager`에 특정 이벤트를 구독하고, 해당 이벤트가 발행되었을 때 정의된 콜백 함수를 실행하는 역할을 수행합니다. `EventEmitter.on()` 메서드를 사용하여 이벤트를 리스닝합니다.
    - **EventManager**:
        - **중앙 집중식 이벤트 관리**: `Node.js EventEmitter`를 상속받거나 포함하여 모든 이벤트 구독 및 발행을 처리하는 중앙 허브 역할을 합니다.
        - **이벤트 등록/해제**: `on()`, `off()` (또는 `removeListener()`) 메서드를 통해 `Subscriber`가 이벤트를 등록하거나 해제할 수 있도록 제공합니다.
        - **이벤트 발행**: `emit()` 메서드를 통해 `Publisher`로부터 받은 이벤트를 구독하고 있는 모든 `Subscriber`에게 전달합니다.
        - **Singleton 패턴 적용**: 애플리케이션 내에서 `EventManager`의 인스턴스가 하나만 존재하도록 Singleton 패턴을 적용하여 일관된 이벤트 관리를 보장합니다.
- **동기, 비동기, 지연 처리가 가능한 이벤트 큐 설계**:
    - **이벤트 큐**: 발행된 이벤트를 임시로 저장하는 큐를 구현합니다. `Array` 또는 `Map`과 같은 자료구조를 활용할 수 있습니다.
    - **처리 방식 구분**:
        - **동기 처리**: `emit()` 호출 시 즉시 구독자에게 이벤트를 전달합니다.
        - **비동기 처리**: `process.nextTick()`, `setImmediate()`, 또는 `setTimeout(..., 0)` 등을 사용하여 이벤트 처리를 이벤트 루프의 다음 틱으로 넘겨 비동기적으로 처리합니다. 이는 현재 호출 스택을 블로킹하지 않도록 합니다.
        - **지연 처리**: 특정 시간(예: `setTimeout(..., delay)`) 이후에 이벤트를 처리하도록 스케줄링합니다.
    - **우선순위 큐 (선택 사항)**: 이벤트의 중요도에 따라 우선순위를 부여하여 처리 순서를 제어할 수 있는 큐를 추가로 고려할 수 있습니다.
        

---

## 💻 구현

### 📌 항목

- **Race Condition 발생 코드 구현**: `worker_threads`를 사용하여 공유 변수에 접근하는 코드를 작성하고, Race Condition이 발생하는 것을 시연합니다.
- **Race Condition 해결 코드 구현**: `Atomics` 또는 다른 동기화 기법을 사용하여 Race Condition을 해결하고, 해결 전후의 결과를 비교합니다.
- **`EventManager` 클래스 구현**: `Node.js EventEmitter`를 활용하여 `EventManager` 클래스를 구현하고, Singleton 패턴을 적용합니다.
- **`Publisher` 및 `Subscriber` 클래스/함수 구현**: `EventManager`와 연동하여 이벤트를 발행하고 구독하는 `Publisher`와 `Subscriber`를 구현합니다.
- **이벤트 큐 및 처리 로직 구현**: 동기, 비동기, 지연 처리 기능을 포함하는 이벤트 큐와 이를 관리하는 로직을 구현합니다.
- **테스트 케이스 작성**: 구현된 기능들이 올바르게 동작하는지 확인하기 위한 테스트 코드를 작성합니다.
</details>

템플릿과 자료를 제공하니 템플릿 형식에 잘 따라 작성해주었습니다. 내용적인 측면에서도 AI 특유의 사족이 조금 있지만 예상보다 더 논리적으로 작성해주어서 한 주간 사용해 보면서 README를 작성 시 틀을 잡는데 도움이 되었던 것 같습니다. 

## QUEST2. AI를 활용한 학습 내용 검증

- 미션을 진행하면서 학습정리를 작성할 때 최대한 신뢰도 있는 자료를 찾으려고 노력하는데, 이 퀘스트를 수행하면 더 쉽게 좋은 자료를 찾고 검증까지 할 수 있을 것 같아 선정하게 되었습니다.

> 내가 아래처럼 파일 시스템에 대해 이해하고 정리했는데,

<details>
<summary>접기/펼치기</summary>

## ❓ 파일 시스템이란?

밑바닥부터 생각해본다면, 우리는 어떻게 하드디스크나 SSD에 데이터나 파일을 저장하고 읽을까?

하드디스크는 미세한 자성물질이 씌워진 원판을 회전시키며 미세한 단위의 자기 방향으로 그 정보를 기록한다. 또한 SSD는 그 이름인 Solid-State Drive와 같이, 회전하는 부품 없이 반도체만으로 정보를 0과 1의 전기적인 신호로 저장한다.

컴퓨터가 이런 보조기억장치의 정보를 읽어들이려면 하드웨어에서 인식한 전기적 정보를 어떻게 해석할 지, 어떤 크기로 입력을 나누어야 최소 단위가 될 지, 읽은 정보를 어떻게 읽어야 그것이 파일이고 그 파일의 정보를 의미하는 건지 많은 결정 기준을 내리고 처리해줄 무언가가 필요하다.

🔷 **파일 시스템**이란, **운영체제에서 파일이나 데이터를 규칙에 따라 효율적으로 하드웨어에 읽고, 쓰고, 검색하고 관리할 수 있도록 체계적으로 관리해주는 인터페이스 & 프로그램**이다. **OS의 커널 요소**로서, 파일 시스템은 물리적인 입력 정보를 해석해 사용자가 이해할 수 있는 파일 시스템 구조로 표현해준다.

각각의 OS마다, 호환이 가능한 파일 시스템이 다르다. Windows를 예시로 들어보면, Windows는 디스크 드라이브를 NTFS라는 파일 시스템 형태로 읽어 사용하는 것이 가장 호환성이 좋은 편이다.

파일 시스템은 저장장치와 사용자 사이에서 데이터를 처리하는 프로그램과 동시에 인터페이스로 동작한다. 특정 파일 시스템의 저장 형식으로 저장장치의 파티션이 구성되어 있다면, OS에서 동작하는 파일 시스템이 그 저장장치를 해당 파일 시스템 형식에 맞게 해석해 논리적으로 파일 시스템을 형성한다.

🔷 정리하면 다음과 같이 나타낼 수 있다.

- 파일 시스템은 물리적인 저장장치에 접근해 OS나 응용 프로그램들이 실제 물리적 데이터를 처리할 필요 없이 파일과 데이터를 다룰 수 있도록 해주는 인터페이스이다.
- 파일 시스템은 저장장치의 물리적 신호 바이트를 논리적인 파일 구조로 조직하고 나타내 우리가 파일과 디렉토리를 조작하면 그에 맞게 저장장치에서 읽고 쓰는 동작을 수행한다.
- OS의 커널에 **파일 시스템을 처리할 수 있는 프로그램**(드라이버)이 존재한다. 이 프로그램이 지원하는 파일 시스템 형식이 서로 다르기 때문에, OS 마다 지원 가능한 파일 시스템이 서로 다르다.
</details>

> 프롬프트 : 이 내용이 
> - IEEE 공식 문서 (ttps://pubs.opengroup.org/onlinepubs/9699919799/)
> - IBM 공식 문서 (https://www.ibm.com/docs/ko/aix/7.2.0?topic=tree-file-system-structure), 
> - Operation System Concepts 도서(https://www.mbit.edu.in/wp-content/uploads/2020/05/Operating_System_Concepts_8th_EditionA4.pdf)
> 위 제시한 공식 자료를 기준으로 정확한지 검증해 줘. 만약 틀리거나 빠진 내용이 있다면 알려줘.

<details>
<summary>접기/펼치기</summary>

### 검증 결과 및 보충/강조 내용

**1. "밑바닥부터 생각해본다면, 우리는 어떻게 하드디스크나 SSD에 데이터나 파일을 저장하고 읽을까?"**

- **정확성**: 하드디스크와 SSD의 물리적 저장 방식에 대한 설명은 간략하지만 정확합니다.
    
- **보충/강조**: 이 부분은 파일 시스템이 **물리적인 저장 매체의 특성과 논리적인 파일 구조 사이의 추상화 계층**임을 잘 보여주는 도입부입니다.
    

**2. "컴퓨터가 이런 보조기억장치의 정보를 읽어들이려면 하드웨어에서 인식한 전기적 정보를 어떻게 해석할 지, 어떤 크기로 입력을 나누어야 최소 단위가 될 지, 읽은 정보를 어떻게 읽어야 그것이 파일이고 그 파일의 정보를 의미하는 건지 많은 결정 기준을 내리고 처리해줄 무언가가 필요하다."**

- **정확성**: 파일 시스템의 필요성을 잘 설명하고 있습니다. 특히 "어떤 크기로 입력을 나누어야 최소 단위가 될 지" 부분은 파일 시스템이 데이터를 **블록(block) 단위**로 관리한다는 핵심 개념을 내포하고 있습니다.
    
- **보충/강조**: 이 "최소 단위"가 곧 "블록" 또는 "클러스터"이며, 파일 시스템은 이러한 논리적인 블록들을 물리적인 디스크 섹터에 매핑하는 역할을 수행합니다.
    

**3. "🔷 파일 시스템이란, 운영체제에서 파일이나 데이터를 규칙에 따라 효율적으로 하드웨어에 읽고, 쓰고, 검색하고 관리할 수 있도록 체계적으로 관리해주는 인터페이스 & 프로그램이다. OS의 커널 요소로서, 파일 시스템은 물리적인 입력 정보를 해석해 사용자가 이해할 수 있는 파일 시스템 구조로 표현해준다."**

- **정확성**: 파일 시스템의 정의를 매우 정확하게 설명하고 있습니다. "인터페이스 & 프로그램"이라는 표현은 추상화 계층으로서의 역할과 실제 구현체로서의 역할을 동시에 잘 나타냅니다. "OS의 커널 요소"라는 점도 중요합니다.
    
- **참고 자료 매칭**:
    
    - **Operating System Concepts (8th Ed., Chapter 10: File-System Interface, Chapter 11: File-System Implementation)**: 파일 시스템을 "파일을 저장하고 조직하는 방법"으로 정의하며, 사용자에게는 논리적인 저장 장치로 보이지만 실제로는 물리적인 디스크 블록에 매핑된다고 설명합니다. 또한, 파일 시스템은 OS의 중요한 컴포넌트이며, 커널의 일부로 구현된다고 명시합니다.
        
    - **IBM 공식 문서**: 파일 시스템이 데이터와 파일을 저장하고 조직하는 구조를 제공하며, 사용자에게 파일에 접근하는 방식을 추상화한다고 설명합니다.
        

**4. "각각의 OS마다, 호환이 가능한 파일 시스템이 다르다. Windows를 예시로 들어보면, Windows는 디스크 드라이브를 NTFS라는 파일 시스템 형태로 읽어 사용하는 것이 가장 호환성이 좋은 편이다."**

- **정확성**: OS마다 지원하는 파일 시스템이 다르다는 점과 Windows의 NTFS 예시는 정확합니다.
    
- **보충/강조**: 이는 파일 시스템이 **특정 OS에 종속적이거나 최적화될 수 있음**을 의미합니다. (예: Linux의 ext4, macOS의 APFS 등)
    

**5. "파일 시스템은 저장장치와 사용자 사이에서 데이터를 처리하는 프로그램과 동시에 인터페이스로 동작한다. 특정 파일 시스템의 저장 형식으로 저장장치의 파티션이 구성되어 있다면, OS에서 동작하는 파일 시스템이 그 저장장치를 해당 파일 시스템 형식에 맞게 해석해 논리적으로 파일 시스템을 형성한다."**

- **정확성**: 파일 시스템의 역할과 동작 방식을 명확하게 설명하고 있습니다. "논리적으로 파일 시스템을 형성한다"는 표현은 물리적 저장 공간 위에 추상화된 계층을 제공한다는 점을 잘 나타냅니다.
    
- **참고 자료 매칭**:
    
    - **Operating System Concepts**: 파일 시스템은 디스크의 물리적 특성을 추상화하여 사용자에게는 논리적인 데이터 저장소로 보이게 한다고 강조합니다. 디스크는 섹터들의 배열로 보이지만, 파일 시스템은 이를 파일과 디렉토리의 계층 구조로 매핑합니다.
        

**6. "🔷 정리하면 다음과 같이 나타낼 수 있다."**

- **첫 번째 항목**: "파일 시스템은 물리적인 저장장치에 접근해 OS나 응용 프로그램들이 실제 물리적 데이터를 처리할 필요 없이 파일과 데이터를 다룰 수 있도록 해주는 인터페이스이다."
    
    - **정확성**: **추상화 계층**으로서의 파일 시스템 역할을 잘 요약했습니다. 매우 중요한 포인트입니다.
        
- **두 번째 항목**: "파일 시스템은 저장장치의 물리적 신호 바이트를 논리적인 파일 구조로 조직하고 나타내 우리가 파일과 디렉토리를 조작하면 그에 맞게 저장장치에서 읽고 쓰는 동작을 수행한다."
    
    - **정확성**: **물리적-논리적 매핑**의 역할을 잘 설명했습니다. 파일과 디렉토리의 개념은 파일 시스템이 제공하는 핵심적인 논리적 구조입니다.
        
- **세 번째 항목**: "OS의 커널에 **파일 시스템을 처리할 수 있는 프로그램**(드라이버)이 존재한다. 이 프로그램이 지원하는 파일 시스템 형식이 서로 다르기 때문에, OS 마다 지원 가능한 파일 시스템이 서로 다르다."
    
    - **정확성**: 파일 시스템 구현이 **커널 내의 모듈 또는 드라이버 형태**로 존재한다는 점을 정확히 언급했습니다. 이는 앞서 "OS의 커널 요소"라는 설명과 일관됩니다.
        

### 빠지거나 보충할 수 있는 내용 (필수적이지는 않으나 이해를 심화시키는 데 도움)

- **메타데이터 (Metadata)**: 파일 시스템의 중요한 역할 중 하나는 파일의 내용뿐만 아니라 파일의 이름, 크기, 생성 날짜, 수정 날짜, 소유자, 접근 권한 등 파일에 대한 정보(메타데이터)를 관리하는 것입니다. 이 메타데이터는 파일 시스템이 파일을 효율적으로 찾고, 관리하며, 접근을 제어하는 데 필수적입니다.
    
- **디렉토리 구조 (Directory Structure)**: 파일 시스템은 일반적으로 계층적인 디렉토리 구조(트리 구조)를 사용하여 파일을 조직합니다. 이는 사용자가 파일을 논리적으로 분류하고 쉽게 탐색할 수 있도록 돕습니다. (IBM 문서는 "tree-structured file system"을 명시)
    
- **파일 시스템의 핵심 기능**:
    
    - **파일 생성 및 삭제 (Create/Delete)**
        
    - **파일 읽기 및 쓰기 (Read/Write)**
        
    - **파일 열기 및 닫기 (Open/Close)**
        
    - **파일 위치 탐색 (Seek)**
        
    - **디렉토리 생성 및 삭제 (Create/Delete Directory)**
        
    - **디렉토리 내용 나열 (List Directory)**
        
- **일관성 및 신뢰성**: 파일 시스템은 시스템 크래시나 전원 장애 시에도 데이터의 일관성과 무결성을 유지하려는 메커니즘을 가집니다 (예: 저널링 파일 시스템). 이 부분은 고급 주제지만, 파일 시스템의 중요성을 더욱 부각시킬 수 있습니다.
    
- **블록 할당 (Block Allocation)**: 파일 시스템은 파일의 데이터를 저장 장치의 블록들에 어떻게 할당할지 결정합니다. 연속 할당, 연결 할당, 색인 할당 등의 방법이 있습니다.
    

### 결론

제시해주신 파일 시스템에 대한 내용은 **매우 정확하고 핵심적인 개념들을 잘 정리**하고 있습니다. IEEE, IBM, Operating System Concepts 도서의 내용을 충실히 반영하고 있으며, 파일 시스템의 본질적인 역할과 필요성을 명확하게 설명합니다. 위에서 제시한 보충 내용들은 이해를 더욱 심화시키기 위한 추가적인 관점이며, 현재 정리된 내용만으로도 파일 시스템에 대한 기본적인 이해를 갖추는 데 전혀 문제가 없습니다.

</details>

- AI가 내리는 평가 자체는 그 평가가 정확한 내용인지 알기가 힘들었습니다.
- 다만 내가 정리한 내용과 공식 문서의 내용을 찾아서 서로 매칭해 주는 것은 내가 정리한 게 맞는 방향인지의 신뢰도 확보에 있어서 꽤 도움이 되었습니다.
- 추가적으로 내가 정리한 내용에서 빠진 부분이 어떤 항목인지를 찾아 덧붙여 주는 것에서 실제로 체크포인트 항목 중 놓친 것을 잡아줬어서 생각보다 괜찮았다고 느꼈습니다.
