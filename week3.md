## 토론 내용

- 미션에 횟수가 정해져있어서 모두 채워야한다는 생각 때문에 수행하기 힘들었다. 미션의 횟수가 있다면 없애는 방향이 좋을 것 같다.
- 계획서를 생성하는 미션은 실제 미션을 진행하기에 계획대로 진행하기 어려웠다.
- 정형화된 상황에서의 코드 구현은 AI를 사용하는 편이 편하지만, AI가 주는 잘못된 정보를 파악하는 힘이 많이 필요하다. 질문하면서 중요하다고 강조하더라도 빠뜨리고 알려줬던 경험이 있어서 잘못된 정보를 받을 위험한 항상 존재하는 것 같다.
- 이번 git 미션과 관련해서 영문서들을 볼 필요가 있었는데 구글 한국어 번역은 맥락을 무시하고 번역하는 바람에 AI를 활용했고 번역과 동시에 해설도 동반하여 알려주는 점이 좋았다.
- AI를 활용하면 모르는 정보를 빠르게 찾아주고 코드를 검증하기 좋았는데 AI 세션을 하다보니 AI에게 내가 학습한 정보를 제공하고 그걸 기반으로 AI를 활용하면 신뢰도가 올라갈 수 있을 것 같다.
- 질문의 의도를 명확하게 작성하지 않으면 내가 원하는 결론을 도출하기 힘들다.

## 📝 과거의 미션

### **1. AI 간단하게 사용해서 자신의 README.md 가독성 향상 시켜보기**

미션에도 도움되고~ AI와도 친해지고~

<img width="300" alt="image" src="https://github.com/user-attachments/assets/d5dd5ef0-28ab-4fa4-a67c-bd6728f54ab9" />

> 위 이미지는 AI에게 부탁해 이미지를 각 조합할 수 있는 SVG 컴포넌트로 만들고 조합해본 사례입니다.

### **2. AI와 함께하는 재미있는 퀴즈 풀어보기**

자기 언어에 맞는 신기한 이상한 퀴즈 내달라하고 풀어보면서 잠깐의 여유를 가져보세요.
그리고 그게 재밌었다면 다른 사람들과 공유해보세요.

참고사이트.

1. [jsisweird.com](https://jsisweird.com/)
2. https://github.com/denysdovhan/wtfjs

```js
// 정답을 유추해보세요..
typeof null;

let b = (10, 2);

"b" + "a" + +"a" + "a";

![];

// 맞춘다면 당신은 js 고수...
```

### 미션 개선

```
당일 미션 내용을 기준으로 퀴즈를 생성한다.
```

### **3. 재미있는 AI 활용 사례 random채널에 공유하기**

노래만들기, 시쓰기, 그림그리기 등 AI를 활용한 재미있는 사례를 찾아서 공유해보세요.

예시)
AI가 만든 추리 게임 진행하기, 슬랙에서 스레드로 이어서 진행

---

"**AI야, 추리 게임을 하고 싶은데 이렇게 진행해줘:**

1. **사건 설정**: 처음부터 모든 기본 정보를 투명하게 제공해줘

   - 장소의 구조, 등장인물들의 관계, 시간대별 동선 등

2. **단서 시스템**:

   - 처음부터 조사 가능한 모든 단서 목록을 보여줘
   - 내가 선택하면 그 단서에 대한 정보를 알려줘
   - 단서끼리 연결해서 추리할 수 있게 해줘

3. **상호작용**:

   - 용의자들에게 질문할 수 있게 해줘
   - 증거물을 조합해볼 수 있게 해줘
   - 내 추리가 맞는지 중간중간 검증할 수 있게 해줘

4. **진행 방식**:
   - 객관식으로 제시해주고, 너가 더블체크해서 이상한 질문지는 걸러줘
   - 막히면 힌트를 요청할 수 있되, 처음부터 정보를 숨기지는 마"

---

<details> 
<summary><bold>[확인] "카페 라떼의 비밀" 사건 지문 답변 예시 </bold></summary>

# 🔍 카페 라떼의 비밀 사건 파일

## 📋 사건 개요

- **발생일시**: 2025년 7월 24일 목요일 오후 3시
- **장소**: 광명시 블루문 카페
- **피해자**: 김민수 (35세, IT 스타트업 'NextGen' CEO)
- **상태**: 의식불명 후 병원 이송, 독극물 중독 의심

## 🏢 장소 정보

### 카페 블루문 구조

```
[2층] VIP룸 (예약제, 최대 4명)
      - 별도 계단 이용
      - CCTV 있음 (정상 작동)

[1층] 일반 홀
      - A구역: 창가석 (A-1~A-5)
      - B구역: 중앙석 (B-1~B-4)
      - C구역: 카운터석 (C-1~C-3)
      - 화장실: 1층 끝
      - CCTV: 입구, 카운터 (A구역 CCTV 고장)
```

## 👥 당일 카페에 있던 사람들

1. **직원**

   - 박지은 (25세): 바리스타, 김민수와 5개월째 안면
   - 최준호 (22세): 아르바이트생, 근무 2주차

2. **손님들**
   - 이서연 (33세): 프리랜서 개발자, B-2 착석
   - 정현우 (29세): NextGen 전 직원, A-1 착석
   - 안소희 (27세): 블로거, C-2 착석
   - 김태준 (42세): 벤처투자자, 2층 VIP룸
   - 한예진 (31세): 김태준의 비서, 2층 VIP룸

## ⏰ 시간대별 동선

- 14:00 - 카페 오픈
- 14:15 - 정현우 입장 (A-1 착석)
- 14:20 - 이서연 입장 (B-2 착석)
- 14:25 - 김태준, 한예진 2층 입장
- 14:30 - 김민수 입장... 그런데 A-3에 누군가 있음
- 14:32 - 김민수 B-3 착석 (평소와 다른 자리)
- 14:35 - 김민수 아이스 카페라떼 주문
- 14:40 - 안소희 입장 (C-2 착석)
- 14:45 - 김민수 커피 수령
- 14:55 - 김민수 커피 마시기 시작
- 15:00 - 김민수 쓰러짐

## 🔎 조사 가능한 단서

1. **김민수의 커피잔** - 독극물 검사 결과 대기중
2. **A-3 테이블** - 김민수의 평소 자리
3. **CCTV 영상** - 입구, 카운터, 2층 (A구역 제외)
4. **쓰레기통** - 카운터 옆, 화장실 앞
5. **김민수의 소지품** - 휴대폰, 지갑, 노트북
6. **주문 기록** - POS 시스템
7. **직원 사물함** - 직원 휴게실
8. **2층 VIP룸** - 별도 조사 필요

---

**무엇을 조사하시겠습니까? 또는 누구에게 질문하시겠습니까?**

(예: "1번 단서 조사", "박지은에게 질문", "정현우와 김민수의 관계는?" 등)

</details>

### **4. 오늘의 일정 작성하면 그거에 맞는 계획표 짜주기**

### 미션 개선

```
내가 작성한 나만의체크포인트를 AI에게 전달하고 각 항목에 대해 난이도와 데드라인 받기
```

---

## 📝 수행하실 미션

### **1. 피어 컴파일링 전, AI로 스터디 그룹원의 리드미의 요약본을 만들고, 실제 리드미와 비교**

### 미션 개선

```
같은 팀원의 README 파일을 제공하고 요약본을 받는다.
피어 컴파일링 시 요약본과 실제 README파일을 비교하며 잘 요약했는지 비교파악을 한다.
```

### 수행방식

- 피어컴파일링 때 피어의 readme를 ai에게 요약해달라고 한다.
- 실제로 잘 요약해주는지 readme를 읽어보고 판단한다.
- 이해하기 쉬워졌다면 쉬워진 이유와 어려워졌다면 어려워진 이유를 기록한다

### 달성기준

- 피어 컴파일링 시 피어의 readme를 이해하는데 걸리는 시간이 줄어들었다면 성공입니다.

### **2. AI와 함께하는 재미있는 퀴즈 풀어보기**

### **3. 새롭게 발표된 AI 모델의 정보나 활용 사례 조사해서 공유하기**

다른 분야에서 AI를 어떻게 활용하고 발전하고 있는지 찾아보고 더 나아가 자신의 분야에도 적용 가능할지 가능성을 찾는 기회를 가져본다.
새로운 AI 모델의 발표 내용이나 정보들을 찾아본다.

정보를 담고 있는 영상의 경우 [릴리스AI](https://lilys.ai/)를 활용해 요약할 수 있다

### 예시

영상 링크:
[AI시대에 알맞은 3D 모델링 방법이 등장했다 | Meshy AI](https://www.youtube.com/watch?v=--7vaX_-0EQ)

요약 결과:
<img width="686" height="414" alt="영상 요약" src="https://github.com/user-attachments/assets/139344ea-4c07-4c09-8727-0f10f19f39bd" />

### **4. 내가 작성한 나만의체크포인트를 AI에게 전달하고 각 항목에 대해 난이도와 데드라인 받기**

### 수행 방식

미션 내용과 그에 따라 자신이 작성한 체크포인트, 그 외 구체적인 조건들을 가지고 AI에 질문한다.

### 달성 기준

일주일에 1번 이상 수행하고, 슬랙 random 채널에 게시.

### 예시

#### 입력

```
1. 미션과 그 미션을 수행하기 위한 체크포인트가 있다.
- 미션 : [미션 내용]
- 체크포인트 :  [체크포인트 내용]

2. 제공된 내용을 바탕으로 각 체크포인트 단계를 완수하기 위한 데드라인을 작성하라.
3. 미션의 내용에 따라 각 체크포인트 별 난이도와 소요시간을 판단하라.
4. 예상 난이도와 소요 시간을 데드라인 산정에 반영하라.
5. 총 미션 수행 시간은 18시간이다.
```

#### 출력

1. 체크포인트 목록 정리 및 난이도·소요시간 평가

| 체크포인트 / 작업 항목           | 설명 요약                                        | 예상 난이도 (1=쉬움,5=어려움) | 추정 소요시간 | 비고                           |
| -------------------------------- | ------------------------------------------------ | ----------------------------- | ------------- | ------------------------------ |
| Constants 생성                   | 상수 정의 (영상 길이, 상태, 이벤트 타입 등)      | 1                             | 0.5h          | 기초                           |
| Task / TaskState 클래스          | 영상 작업과 상태 모델링                          | 2                             | 1h            | 상태 전이 고려                 |
| EventEmitter 생성                | 이벤트 전파 기반 구조의 핵심 구현                | 3                             | 1h            | 비동기 이벤트 흐름 중심        |
| Queue 클래스                     | 등록 대기 큐 구현 (FIFO, 이벤트 배정)            | 2                             | 1h            | 동시성 고려 최소화             |
| EventLooper 클래스               | 큐에서 이벤트 꺼내 처리하는 루퍼                 | 3                             | 1.5h          | 주기적 체크/스케줄링           |
| UploadManager 클래스             | 업로드 요청 수신 + 대기큐 삽입 + 진행판 알림     | 3                             | 1.5h          | 입력 파싱 포함                 |
| 변환 모듈 (Single)               | 단편/중편/장편 변환 로직 + 시작/종료 이벤트      | 4                             | 2h            | 길이에 따라 시간 차등 처리     |
| 라이센스 검증 모듈 (Single)      | 검증 시작/완료 이벤트 (고정 10분)                | 3                             | 1.5h          | 변환 후 연결                   |
| DashBoard 클래스                 | 전체 상태 주기 출력 (대기/변환/검증/공개)        | 3                             | 1.5h          | 이벤트 수신 기반 렌더링        |
| 기본 흐름 통합 테스트            | 위 모듈들을 연결해 1개 서버 + 1개 변환/검증 흐름 | 3                             | 1.5h          | 시뮬레이션 입력/출력 확인      |
| Gist 커밋 + 공개 설정            | 각 구성 요소 구현마다 gist commit & 공개         | 1                             | 1h            | 병행하지만 시간 할당 포함      |
| 확장: 여러 변환/검증 모듈 & 분류 | 단편/중편/장편별 전담 + 작업 분배/카운트         | 5                             | 2h            | 확장성과 동시에 처리 제한 고려 |

2. 우선순위 기반 일정 (데드라인)

시작: 2025년 8월 1일 오전 10:00 (예시)

1일차 (8/1): 총 7.5시간

- 10:00–10:30 Constants 생성. (0.5h)
- 10:30–11:30 Task / TaskState 클래스. (1h)
- 11:30–12:30 EventEmitter 생성. (1h)
- 12:30–13:30 Queue 클래스. (1h)
- 13:30–14:30 점심 휴식 (비공식, 일정에 여유)
- 14:30–16:00 EventLooper 클래스. (1.5h)
- 16:00–17:30 UploadManager 클래스. (1.5h)
- 17:30–18:00 해당 구현들 gist 커밋 & 공개. (0.5h)

8/1 마감 목표: 기본 인프라(이벤트, 큐, 업로드) 완성, 관련 gist 공개.

2일차 (8/2): 총 6.5시간

- 10:00–12:00 변환 모듈 (단편/중편/장편 길이 처리 포함). (2h)
- 12:00–13:30 라이센스 검증 모듈 구현. (1.5h)
- 13:30–14:30 점심
- 14:30–16:00 DashBoard 클래스 구현. (1.5h)
- 16:00–17:30 기본 흐름 통합 테스트 + 시뮬레이션. (1.5h)
- 17:30–18:00 중간 gist 커밋 & 공개. (0.5h)

8/2 마감 목표: 단일 변환/검증 + 진행판 포함한 전체 흐름 완전 작동.

3일차 (8/3): 총 4시간

- 10:00–12:00 확장: 여러 변환/검증 모듈 & 단편/중편/장편 분류 + 작업 분배/카운트 로직. (2h)
- 12:00–13:00 확장된 흐름 테스트 (동시 처리 제한, 상태 집계 확인). (1h)
- 13:00–14:00 최종 정리 + 모든 컴포넌트별 gist 커밋 & 공개 + 문서화(설계 요약 기록). (1h)

8/3 마감 목표: 확장된 구조 완성, 모든 체크포인트 구현 완료 및 공개.

3. 시간 여유 및 버퍼
   각 날에 30분~1시간 정도 예기치 않은 버그/조정 대비 여유를 둠 (전체 1.5h 내외는 이미 추정에 포함된 커밋/통합/테스트 시간으로 흡수).

필요하다면 8/4 오전(2시간 이내)까지 버퍼로 활용 가능.

4. 요약된 데드라인 표

| 항목                                                                        | 완료 데드라인    |
| --------------------------------------------------------------------------- | ---------------- |
| Constants, Task/State, EventEmitter, Queue, Looper, UploadManager + 첫 커밋 | 2025-08-01 18:00 |
| 변환/검증 모듈, DashBoard, 통합 테스트 + 중간 커밋                          | 2025-08-02 18:00 |
| 확장(다중 모듈/분류) + 최종 테스트/커밋/문서화                              | 2025-08-03 14:00 |

5. 우선순위 제안

   1. 이벤트 인프라 (Emitter, Queue, Looper) - 모든 흐름의 기반.

   2. 업로드 & 상태 모델 - 입력과 표현 기준 확립.

   3. 변환/검증 + 대조 흐름 통합 - 실제 비즈니스 로직.

   4. DashBoard - 가시화, 상태 추적.

   5. 확장성(여러 모듈, 분류, 카운트) - 스케일업/완성도.

   6. 지속적 커밋 + 문서화 - 증적/공개 요구사항 충족.

---

## 퀘스트 이어받기

### J293

### 퀘스트 선택

- 피어 컴파일링 전, AI로 스터디 그룹원의 리드미의 요약본을 만들고, 실제 리드미와 비교

### 선택 이유

- 시간이 없어서 팀원들의 README를 제대로 숙지하지 못하고 피어 컴파일링을 하는 경우가 있는데 이런 경우에 효과적일 것 같다.
- 효과적으로 정리하기 위한 프롬프트를 새로 만들어 볼 수 있을 거 같다.
- 피어 컴파일링 시간을 더 효과적으로 사용할 수 있을 것 같다.

### 미션 수행

사용 프롬프트

```
아래의 README 파일을 읽고, 주요 내용(프로젝트 목적, 사용 기술, 구현 방법, 주요 결과, 주의사항 등)을 항목별로 간략하고 논리적으로 요약해줘.
각 항목의 중요도에 따라 굵게 강조하고, 예시나 핵심 코드가 있다면 간단히 첨부해줘.
모르는 내용이나 불확실한 부분이 있으면 '추가 확인 필요'로 명시해줘.
```

#### 미션 수행 날짜 : 8/04 (월)

#### 미션 내용

![릴프7.png](https://raw.githubusercontent.com/JongKyuHong/image/main/릴프7.png)

![릴프8.png](https://raw.githubusercontent.com/JongKyuHong/image/main/릴프8.png)

#### 느낀점

피어 컴파일링때 팀원분들 READMD의 흐름을 잘 이해하지 못할 때가 있는데 AI로 요약을 시킴으로써 흐름을 파악하기도 쉽고, 피곤한 아침 시간대에 많이 도움 된 것 같습니다!

---

### J118

### 퀘스트 선택

[퀘스트1] 피어 컴파일링 전, AI로 스터디 그룹원의 리드미의 요약본을 만들고, 실제 리드미와 비교

### 선택 이유

다른 사람이 작성한 낯선 문서를 처음 접할 때는 파악하고 몰입하는 데 시간이 꽤 걸리고, 이해하는 것도 쉽지 않은 것같습니다. 피어 피드백을 하기전에, 피어의 리드미를 AI가 잘 요약해서 제공해주면 전체 맥락을 빠르게 파악할 수있어 내용을 이해하는데 도움이 될 것같습니다. 이를 통해 피어 피드백에서 피어분들에게 의미있는 피드백을 드리는 데 도움이 될 것 같습니다.

#### 미션 수행

![](https://i.imgur.com/5ZOgUsP.png)

![](https://i.imgur.com/O2XUfdf.png)

느낀점

- 각 항목별로의 요약, 전체적인 흐름 파악, 체크리스트는 피어피드백 때 어느정도 도움이 된것같다.

아쉬운점

- 리드미에는 설계, 흐름 등을 그림으로 설명하는 경우가 많다. 지피티에 입력되지 않은 그림들이 빠져서 맥락파악에 포함되지 않는다는 점이 아쉬웠다.

---
  
### J285

### 퀘스트 선택

2. AI와 함께하는 재미있는 퀴즈 풀어보기

### 선택 이유

재미 위주의 퀘스트를 원했고, JS에 대해 생각해보지 못한 점들을 알 수 있을 것 같아서 선택했습니다.

### 미션 수행

#### 프롬프트 
`이러한 쇼핑 서비스 미션과 관련하여,
jsisweird.com
https://github.com/denysdovhan/wtfjs
위 사이트를 참고하여 JS의 신기한, 이상한 퀴즈를 만들어줘`

<details>
<summary>AI 답변</summary>
<div markdown="1">

네, 쇼핑 서비스 과제에 영감을 받아, `wtfjs`와 `jsisweird.com`의 재미있는 사례들을 바탕으로 자바스크립트 퀴즈를 만들어 보았습니다.

-----

## 🛒 쇼핑몰 백엔드 개발자를 위한 JS 함정 퀴즈

쇼핑 서비스 과제를 진행하시면서 겪을 수 있는 자바스크립트의 신기하고 이상한 함정 퀴즈입니다. 과연 몇 개나 맞추실 수 있을까요?

### 퀴즈 \#1: 텅 빈 장바구니의 덧셈

쇼핑몰에서 비어있는 두 장바구니(배열)를 합치거나, 비어있는 고객 정보(객체)와 장바구니를 합치면 어떤 일이 일어날까요?

**문제**

```javascript
// 1. 빈 장바구니 + 빈 장바구니
console.log([] + []);

// 2. 빈 고객 정보 + 빈 장바구니
console.log({} + []);
```

위 두 `console.log`의 결과는 각각 무엇일까요?

**정답 및 해설**

```javascript
// 1. 결과: "" (빈 문자열)
// 2. 결과: 0 (숫자 0) 또는 [object Object] (브라우저 환경에 따라 다름)
```

**이유는 이렇습니다:**

1.  **`[] + []`**: `+` 연산자는 한쪽이라도 객체나 배열이면, 다른 쪽을 원시값으로 변환하려는 시도를 합니다. 배열의 기본 원시값은 `toString()` 메서드를 통해 얻는데, 빈 배열 `[]`의 `toString()` 결과는 빈 문자열 `""`입니다. 따라서 `"" + ""`와 같은 연산이 되어 결과는 `""`가 됩니다.

2.  **`{} + []`**: 이 경우는 조금 더 복잡합니다.

      * **Node.js 환경:** `{}`가 빈 코드 블록으로 해석되어 무시되고, `+[]` 연산만 남게 됩니다. `+`를 숫자 변환 연산자로 본 자바스크립트는 `[]`를 숫자로 바꾸려고 시도하고, 그 결과 `0`이 됩니다.
      * **브라우저 콘솔 환경:** `{}`가 객체 리터럴로 인식됩니다. `[object Object]`라는 문자열로 변환된 후, `[]`가 변환된 `""`와 더해져 `"[object Object]"`라는 문자열이 됩니다.

**쇼핑몰 적용 팁**: 서로 다른 타입의 데이터를 `+` 연산자로 합치는 것은 예측 불가능한 결과를 낳을 수 있습니다. 항상 데이터의 타입을 명확히 하거나, 명시적으로 `String()` 또는 `Number()`로 변환 후 연산하는 것이 안전합니다.

-----

### 퀴즈 \#2: 정확한 가격 계산?

고객이 100원짜리 상품과 200원짜리 상품을 구매했습니다. 총액에 10%의 부가세를 더하려고 합니다.

**문제**

```javascript
const priceA = 0.1; // 100원을 1000원으로 나눈 값
const priceB = 0.2; // 200원을 1000원으로 나눈 값

console.log(priceA + priceB === 0.3);
```

위 `console.log`의 결과는 `true`일까요, `false`일까요?

**정답 및 해설**

```javascript
// 결과: false
```

**이유는 이렇습니다:**

자바스크립트를 포함한 대부분의 프로그래밍 언어는 부동소수점 숫자를 처리할 때 **IEEE 754 표준**을 따릅니다. 이 표준은 2진법을 기반으로 하기 때문에, 0.1이나 0.2 같은 일부 십진수 소수를 정확하게 표현하지 못하고 아주 미세한 오차가 있는 근사치로 저장합니다.

실제로 `0.1 + 0.2`를 계산하면 `0.30000000000000004`와 같은 결과가 나오므로, `0.3`과 비교하면 `false`가 됩니다.

**쇼핑몰 적용 팁**: **절대 돈(가격) 계산에 부동소수점을 직접 사용하면 안 됩니다.** 모든 가격을 가장 작은 단위의 정수(예: '원' 대신 '전')로 저장하고 계산한 뒤, 사용자에게 보여줄 때만 소수점으로 변환하는 것이 가장 안전하고 표준적인 방법입니다.

-----

### 퀴즈 \#3: 상품 정렬의 함정

MD가 상품 목록을 재고 수량 순으로 정렬하려고 합니다.

**문제**

```javascript
const inventory = [
  { name: '상품A', stock: 100 },
  { name: '상품B', stock: 20 },
  { name: '상품C', stock: 9 }
];

// 재고(stock) 기준으로 정렬
const sorted = inventory.map(item => item.stock).sort();

console.log(sorted);
```

위 `console.log`의 결과는 어떻게 나올까요?

**정답 및 해설**

```javascript
// 결과: [100, 20, 9]
```

**이유는 이렇습니다:**

배열의 `sort()` 메서드는 기본적으로 모든 요소를 **문자열로 취급하여 사전 순서(lexicographical order)로 정렬**합니다. 따라서 숫자 `100`, `20`, `9`를 문자열 `"100"`, `"20"`, `"9"`로 보고 정렬합니다.

문자열 정렬에서는 첫 번째 글자부터 비교하므로 `"1"`이 `"2"`나 `"9"`보다 앞에 오게 되어 위와 같은 결과가 나옵니다.

**쇼핑몰 적용 팁**: 숫자를 제대로 정렬하려면 `sort()` 메서드에 \*\*비교 함수(compare function)\*\*를 반드시 전달해야 합니다.

```javascript
// 올바른 숫자 정렬
const correctlySorted = inventory.map(item => item.stock).sort((a, b) => a - b);
console.log(correctlySorted); // [9, 20, 100]
```

</div>
</details>

<details>
<summary>AI 답변2</summary>
<div markdown="1">

JavaScript의 특이한 동작들을 쇼핑 서비스 맥락에서 재미있는 퀴즈로 만들어보겠습니다.

```javascript
// 🛍️ 쇼핑몰 JavaScript 퀴즈 🤔

// 1️⃣ 재고 비교
const stock1 = 0;
const stock2 = false;
const stock3 = "";
const stock4 = [];

console.log("Q1. 다음 중 true는 몇 개일까요?");
console.log(stock1 == stock2);  // ?
console.log(stock2 == stock3);  // ?
console.log(stock3 == stock4);  // ?
console.log(stock4 == stock1);  // ?

// 2️⃣ 장바구니 합계
console.log("Q2. 장바구니 합계는 얼마일까요?");
console.log(["5"] + 3);        // ?
console.log(["5"] - 3);        // ?
console.log([5] + [3]);        // ?
console.log([5, 3] + [1, 2]);  // ?

// 3️⃣ 상품 ID 정렬
console.log("Q3. 상품 ID 정렬 결과는?");
console.log(['P2', 'P10', 'P1'].sort());  // ?

// 4️⃣ 재고 계산
console.log("Q4. 재고 계산 결과는?");
console.log(0.1 + 0.2 === 0.3);  // ?
console.log(999999999999999);     // ?
console.log(9999999999999999);    // ?

// 5️⃣ 장바구니 아이템 체크
const cart = {
  items: ["apple"]
};

console.log("Q5. 장바구니 검사 결과는?");
console.log(cart.items?.[0]?.[0]?.toLowerCase());  // ?
console.log(cart.items?.[0]?.[0]?.toUpperCase?.());  // ?
console.log(cart.items?.[1]?.[0]?.toUpperCase?.());  // ?

// 6️⃣ 상품 가격 비교
console.log("Q6. 가격 비교 결과는?");
console.log(NaN === NaN);  // ?
console.log(Object.is(NaN, NaN));  // ?
console.log(Math.max());  // ?
console.log(Math.min());  // ?

// 7️⃣ 상품 ID 생성
console.log("Q7. 생성된 ID는?");
console.log(['P', 1] + ['S', 2]);  // ?
console.log({} + []);  // ?
console.log([] + {});  // ?
```

**정답과 설명:**

1️⃣ 재고 비교
```javascript
console.log(stock1 == stock2);  // true (0 == false)
console.log(stock2 == stock3);  // true (false == "")
console.log(stock3 == stock4);  // true ("" == [])
console.log(stock4 == stock1);  // true ([] == 0)
```
설명: JavaScript의 느슨한 동등 비교(==)는 타입 강제 변환을 수행합니다. 빈 배열은 0으로, 빈 문자열은 false로 변환됩니다.

2️⃣ 장바구니 합계
```javascript
console.log(["5"] + 3);        // "53" (문자열 연결)
console.log(["5"] - 3);        // 2 (숫자 뺄셈)
console.log([5] + [3]);        // "53" (배열->문자열 변환 후 연결)
console.log([5, 3] + [1, 2]);  // "5,31,2" (배열->문자열 변환 후 연결)
```
설명: + 연산자는 문자열 연결을 우선하지만, - 연산자는 숫자 연산만 수행합니다.

3️⃣ 상품 ID 정렬
```javascript
console.log(['P2', 'P10', 'P1'].sort());  // ['P1', 'P10', 'P2']
```
설명: 기본 sort()는 문자열 기준으로 정렬하므로 'P10'이 'P2'보다 앞에 옵니다.

4️⃣ 재고 계산
```javascript
console.log(0.1 + 0.2 === 0.3);  // false (부동소수점 오차)
console.log(999999999999999);     // 999999999999999
console.log(9999999999999999);    // 10000000000000000
```
설명: JavaScript는 IEEE 754 부동소수점을 사용하며, 특정 숫자는 정확히 표현할 수 없습니다.

5️⃣ 장바구니 아이템 체크
```javascript
console.log(cart.items?.[0]?.[0]?.toLowerCase());  // "a"
console.log(cart.items?.[0]?.[0]?.toUpperCase?.());  // "A"
console.log(cart.items?.[1]?.[0]?.toUpperCase?.());  // undefined
```
설명: 옵셔널 체이닝(?.)을 사용하면 중간에 null/undefined가 있어도 안전하게 접근할 수 있습니다.

6️⃣ 상품 가격 비교
```javascript
console.log(NaN === NaN);  // false
console.log(Object.is(NaN, NaN));  // true
console.log(Math.max());  // -Infinity
console.log(Math.min());  // Infinity
```
설명: NaN은 자신과도 같지 않으며, 인자가 없을 때 Math.max와 Math.min은 의외의 결과를 반환합니다.

7️⃣ 상품 ID 생성
```javascript
console.log(['P', 1] + ['S', 2]);  // "P1S2"
console.log({} + []);  // "[object Object]"
console.log([] + {});  // "[object Object]"
```
설명: 배열과 객체의 + 연산은 toString() 메서드를 호출한 후 문자열을 연결합니다.

이러한 특이한 동작들은 실제 코딩에서 버그의 원인이 될 수 있으므로, 엄격한 비교(===)를 사용하고 명시적인 타입 변환을 하는 것이 좋습니다.

</div>
</details>

### 느낀 점
JS는 특이한 언어라서 이러한 퀴즈를 많이 만들 수는 있는데, 미션과 연관된 퀴즈로 범위를 제한하니까 최대한 미션과 엮어보려는 AI의 노력을 엿볼 수 있었다.
퀴즈를 모두 맞히지는 못했지만, 풀이를 보며 JS 문법에 대해 넓은 잔지식들을 학습하는 데에는 도움이 되었다고 생각한다.

---

### J094

### 퀘스트 선택

2. AI와 함께하는 재미있는 퀴즈 풀어보기

### 선택 이유

AI 만의 독특한 퀴즈를 한번 풀어보고 싶어 선택했습니다

#### 프롬프트

**벡터 데이터베이스에 관련하여 공부하고 싶은데 진짜 기똥차고 재미있는 퀴즈 2문제를 내줘**

<details>
   <summary>문제목록</summary>

### 🧠 퀴즈 1: 벡터 데이터베이스의 심리전

#### 당신은 검색 엔진 개발자다. 사용자가 '달콤한 초콜릿 케이크'를 검색했을 때, 아래 중 어떤 방식으로 유사한 문장을 벡터 데이터베이스가 가장 잘 찾아낼 수 있을까?

A. 입력된 문장을 그대로 문자열 비교하여 유사한 문장을 찾는다
B. 각 단어의 개수를 세서 문장 벡터로 만든 뒤, 유클리드 거리로 가장 가까운 문장을 찾는다
C. 딥러닝 기반 임베딩 모델을 사용하여 문장을 고차원 벡터로 바꾸고, 코사인 유사도로 가장 가까운 벡터를 찾는다
D. 검색어에 포함된 명사를 추출해 정렬한 뒤, 가장 비슷한 단어 조합을 가진 문장을 찾는다

### 🤖 퀴즈 2: 벡터 DB가 사람이라면?

#### 어느 날, 벡터 데이터베이스 '벡디'가 인간이 되어 면접을 보러 왔다. 면접관이 이렇게 물었다.

`“당신은 왜 기존의 관계형 DB보다 인공지능 서비스에 적합하다고 생각하나요?”`

#### 벡디의 말로 적절한 답변은 무엇일까?

A. "저는 SQL을 잘 알아서 인공지능이 저를 쉽게 사용할 수 있어요!"
B. "저는 고정된 스키마를 강제로 적용해서 데이터를 안전하게 보관하죠!"
C. "저는 고차원 의미 벡터를 저장하고, 빠르게 k-NN 탐색을 할 수 있어요!"
D. "저는 메모리에만 데이터를 저장해서 하드디스크와는 거리가 멀죠!"

🎯 정답은? 가장 "벡터 데이터베이스다운" 말을 골라보자!
</details>
<details>
   <summary>정답</summary>

### 정답은: 3번 (C) ✅
```
   🧾 해설:
벡터 데이터베이스는 단순 문자열 비교가 아닌, 딥러닝 기반의 임베딩 모델(예: Sentence-BERT, CLIP, OpenAI Embeddings 등)을 사용해서 문장이나 이미지 같은 비정형 데이터를 고차원 벡터로 변환합니다.
그 다음, 코사인 유사도나 내적, L2 거리 등을 이용해 가장 가까운 벡터들을 찾는 방식으로 동작합니다.
이걸 k-NN (k-Nearest Neighbors) 탐색이라 불러요.
```

### 정답은: 3번 (C) ✅

```
🧾 해설:
벡터 데이터베이스는 특히 AI와의 찰떡궁합입니다!

텍스트, 이미지, 오디오 등의 비정형 데이터를 임베딩 벡터로 바꾸고

그 벡터들 간의 유사도를 바탕으로 가장 가까운 결과를 빠르게 찾아낼 수 있죠.

AI 모델이 생성한 벡터와 기존 벡터들을 비교할 때 이보다 좋은 친구는 없어요.
```
</details>
