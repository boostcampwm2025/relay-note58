## 토론 내용
- 미션에 횟수가 정해져있어서 모두 채워야한다는 생각 때문에 수행하기 힘들었다. 미션의 횟수가 있다면 없애는 방향이 좋을 것 같다.
- 계획서를 생성하는 미션은 실제 미션을 진행하기에 계획대로 진행하기 어려웠다.
- 정형화된 상황에서의 코드 구현은 AI를 사용하는 편이 편하지만, AI가 주는 잘못된 정보를 파악하는 힘이 많이 필요하다. 질문하면서 중요하다고 강조하더라도 빠뜨리고 알려줬던 경험이 있어서 잘못된 정보를 받을 위험한 항상 존재하는 것 같다.
- 이번 git 미션과 관련해서 영문서들을 볼 필요가 있었는데 구글 한국어 번역은 맥락을 무시하고 번역하는 바람에 AI를 활용했고 번역과 동시에 해설도 동반하여 알려주는 점이 좋았다.
- AI를 활용하면 모르는 정보를 빠르게 찾아주고 코드를 검증하기 좋았는데 AI 세션을 하다보니 AI에게 내가 학습한 정보를 제공하고 그걸 기반으로 AI를 활용하면 신뢰도가 올라갈 수 있을 것 같다.
- 질문의 의도를 명확하게 작성하지 않으면 내가 원하는 결론을 도출하기 힘들다.

## 📝 미션

### **1. AI 간단하게 사용해서 자신의 README.md 가독성 향상 시켜보기**

미션에도 도움되고~ AI와도 친해지고~

<img width="300" alt="image" src="https://github.com/user-attachments/assets/d5dd5ef0-28ab-4fa4-a67c-bd6728f54ab9" />

> 위 이미지는 AI에게 부탁해 이미지를 각 조합할 수 있는 SVG 컴포넌트로 만들고 조합해본 사례입니다.


### 미션 개선
```
같은 팀원의 README 파일을 제공하고 요약본을 받는다.
피어 컴파일링 시 요약본과 실제 README파일을 비교하며 잘 요약했는지 비교파악을 한다.
```


### **2. AI와 함께하는 재미있는 퀴즈 풀어보기**

자기 언어에 맞는 신기한 이상한 퀴즈 내달라하고 풀어보면서 잠깐의 여유를 가져보세요.
그리고 그게 재밌었다면 다른 사람들과 공유해보세요.

참고사이트.

1. [jsisweird.com](https://jsisweird.com/)
2. https://github.com/denysdovhan/wtfjs

```js
// 정답을 유추해보세요..
typeof null;

let b = (10, 2);

"b" + "a" + +"a" + "a";

![];

// 맞춘다면 당신은 js 고수...
```

### 미션 개선
```
당일 미션 내용을 기준으로 퀴즈를 생성한다.
```




### **3. 재미있는 AI 활용 사례 random채널에 공유하기**
다른 분야에서 AI를 어떻게 활용하고 발전하고 있는지 찾아보고 더 나아가 자신의 분야에도 적용 가능할지 가능성을 찾는 기회를 가져본다.
새로운 AI 모델의 발표 내용이나 정보들을 찾아본다.

정보를 담고 있는 영상의 경우 [릴리스AI](https://lilys.ai/)를 활용해 요약할 수 있다

### 예시
영상 링크: [AI시대에 알맞은 3D 모델링 방법이 등장했다 | Meshy AI](https://www.youtube.com/watch?v=--7vaX_-0EQ)

요약 결과: 




### **4. 나만의 체크포인트를 계획하기**

### 미션 개선
```
내가 작성한 나만의체크포인트를 AI에게 전달하고 각 항목에 대해 난이도와 데드라인 받기
```

### 예시

#### 입력
```
1. 미션과 그 미션을 수행하기 위한 체크포인트가 있다.
- 미션 : [미션 내용]
- 체크포인트 :  [체크포인트 내용]

2. 제공된 내용을 바탕으로 각 체크포인트 단계를 완수하기 위한 데드라인을 작성하라.
3. 미션의 내용에 따라 각 체크포인트 별 난이도와 소요시간을 판단하라.
4. 예상 난이도와 소요 시간을 데드라인 산정에 반영하라.
5. 총 미션 수행 시간은 18시간이다.
```

#### 출력

1. 체크포인트 목록 정리 및 난이도·소요시간 평가

| 체크포인트 / 작업 항목        | 설명 요약                          | 예상 난이도 (1=쉬움,5=어려움) | 추정 소요시간 | 비고                |
| -------------------- | ------------------------------ | ------------------- | ------- | ----------------- |
| Constants 생성         | 상수 정의 (영상 길이, 상태, 이벤트 타입 등)    | 1                   | 0.5h    | 기초                |
| Task / TaskState 클래스 | 영상 작업과 상태 모델링                  | 2                   | 1h      | 상태 전이 고려          |
| EventEmitter 생성      | 이벤트 전파 기반 구조의 핵심 구현            | 3                   | 1h      | 비동기 이벤트 흐름 중심     |
| Queue 클래스            | 등록 대기 큐 구현 (FIFO, 이벤트 배정)      | 2                   | 1h      | 동시성 고려 최소화        |
| EventLooper 클래스      | 큐에서 이벤트 꺼내 처리하는 루퍼             | 3                   | 1.5h    | 주기적 체크/스케줄링       |
| UploadManager 클래스    | 업로드 요청 수신 + 대기큐 삽입 + 진행판 알림    | 3                   | 1.5h    | 입력 파싱 포함          |
| 변환 모듈 (Single)       | 단편/중편/장편 변환 로직 + 시작/종료 이벤트     | 4                   | 2h      | 길이에 따라 시간 차등 처리   |
| 라이센스 검증 모듈 (Single)  | 검증 시작/완료 이벤트 (고정 10분)          | 3                   | 1.5h    | 변환 후 연결           |
| DashBoard 클래스        | 전체 상태 주기 출력 (대기/변환/검증/공개)      | 3                   | 1.5h    | 이벤트 수신 기반 렌더링     |
| 기본 흐름 통합 테스트         | 위 모듈들을 연결해 1개 서버 + 1개 변환/검증 흐름 | 3                   | 1.5h    | 시뮬레이션 입력/출력 확인    |
| Gist 커밋 + 공개 설정      | 각 구성 요소 구현마다 gist commit & 공개  | 1                   | 1h      | 병행하지만 시간 할당 포함    |
| 확장: 여러 변환/검증 모듈 & 분류 | 단편/중편/장편별 전담 + 작업 분배/카운트       | 5                   | 2h      | 확장성과 동시에 처리 제한 고려 |

2. 우선순위 기반 일정 (데드라인)

시작: 2025년 8월 1일 오전 10:00 (예시)

1일차 (8/1): 총 7.5시간
   10:00–10:30 Constants 생성. (0.5h)
   
   10:30–11:30 Task / TaskState 클래스. (1h)
   
   11:30–12:30 EventEmitter 생성. (1h)
   
   12:30–13:30 Queue 클래스. (1h)
   
   13:30–14:30 점심 휴식 (비공식, 일정에 여유)
   
   14:30–16:00 EventLooper 클래스. (1.5h)
   
   16:00–17:30 UploadManager 클래스. (1.5h)
   
   17:30–18:00 해당 구현들 gist 커밋 & 공개. (0.5h)
   
   8/1 마감 목표: 기본 인프라(이벤트, 큐, 업로드) 완성, 관련 gist 공개.

2일차 (8/2): 총 6.5시간
   10:00–12:00 변환 모듈 (단편/중편/장편 길이 처리 포함). (2h)
   
   12:00–13:30 라이센스 검증 모듈 구현. (1.5h)
   
   13:30–14:30 점심
   
   14:30–16:00 DashBoard 클래스 구현. (1.5h)
   
   16:00–17:30 기본 흐름 통합 테스트 + 시뮬레이션. (1.5h)
   
   17:30–18:00 중간 gist 커밋 & 공개. (0.5h)
   
   8/2 마감 목표: 단일 변환/검증 + 진행판 포함한 전체 흐름 완전 작동.
   
   3일차 (8/3): 총 4시간
   10:00–12:00 확장: 여러 변환/검증 모듈 & 단편/중편/장편 분류 + 작업 분배/카운트 로직. (2h)
   
   12:00–13:00 확장된 흐름 테스트 (동시 처리 제한, 상태 집계 확인). (1h)
   
   13:00–14:00 최종 정리 + 모든 컴포넌트별 gist 커밋 & 공개 + 문서화(설계 요약 기록). (1h)
   
   8/3 마감 목표: 확장된 구조 완성, 모든 체크포인트 구현 완료 및 공개.

3. 시간 여유 및 버퍼
각 날에 30분~1시간 정도 예기치 않은 버그/조정 대비 여유를 둠 (전체 1.5h 내외는 이미 추정에 포함된 커밋/통합/테스트 시간으로 흡수).

필요하다면 8/4 오전(2시간 이내)까지 버퍼로 활용 가능.

4. 요약된 데드라인 표

| 항목                                                                       | 완료 데드라인          |
| ------------------------------------------------------------------------ | ---------------- |
| Constants, Task/State, EventEmitter, Queue, Looper, UploadManager + 첫 커밋 | 2025-08-01 18:00 |
| 변환/검증 모듈, DashBoard, 통합 테스트 + 중간 커밋                                      | 2025-08-02 18:00 |
| 확장(다중 모듈/분류) + 최종 테스트/커밋/문서화                                             | 2025-08-03 14:00 |

5. 우선순위 제안
   1. 이벤트 인프라 (Emitter, Queue, Looper) - 모든 흐름의 기반.
   
   2. 업로드 & 상태 모델 - 입력과 표현 기준 확립.
   
   3. 변환/검증 + 대조 흐름 통합 - 실제 비즈니스 로직.
   
   4. DashBoard - 가시화, 상태 추적.
   
   5. 확장성(여러 모듈, 분류, 카운트) - 스케일업/완성도.
   
   6. 지속적 커밋 + 문서화 - 증적/공개 요구사항 충족.


<br/><br/>



